// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef VOTABLE1_1_HXX
#define VOTABLE1_1_HXX

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030100L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>
#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/tree/parsing.hxx>

#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/xml/dom/namespace-infomap.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type<type> simple_type;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef integer non_positive_integer;
  typedef integer non_negative_integer;
  typedef integer positive_integer;
  typedef integer negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef long double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken> nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::day< char, simple_type > day;
  typedef ::xsd::cxx::tree::month< char, simple_type > month;
  typedef ::xsd::cxx::tree::month_day< char, simple_type > month_day;
  typedef ::xsd::cxx::tree::year< char, simple_type > year;
  typedef ::xsd::cxx::tree::year_month< char, simple_type > year_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::serialization< char > serialization;
  typedef ::xsd::cxx::tree::no_namespace_mapping< char > no_namespace_mapping;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::xsi_already_in_use< char > xsi_already_in_use;
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  // Parsing/serialization error.
  //
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::errors< char > errors;

  // Error handler interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // Namespace information. Used in serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // DOM user data key for back pointers to tree nodes.
  //
#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA

  const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;

#endif
}

// Forward declarations.
//
namespace votable
{
  class anyTEXT;
  class astroYear;
  class ucdType;
  class arrayDEF;
  class encodingType;
  class dataType;
  class precType;
  class yesno;
  class VOTABLE;
  class RESOURCE;
  class DEFINITIONS;
  class INFO;
  class PARAM;
  class TABLE;
  class FIELD;
  class GROUP;
  class FIELDref;
  class PARAMref;
  class VALUES;
  class MIN;
  class MAX;
  class OPTION;
  class LINK;
  class DATA;
  class TABLEDATA;
  class TD;
  class TR;
  class FITS;
  class BINARY;
  class STREAM;
  class COOSYS;
  class version;
  class type;
  class type1;
  class type2;
  class content_role;
  class type3;
  class actuate;
  class system;
}


#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace votable
{
  class anyTEXT: public ::xml_schema::type
  {
    public:

    struct _xsd_anyTEXT
    {
      typedef ::xml_schema::type base_;
    };

    // Constructors.
    //
    public:
    anyTEXT ();

    anyTEXT (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    anyTEXT (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    anyTEXT (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    anyTEXT (const anyTEXT&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    virtual anyTEXT*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;
  };

  class astroYear: public ::xml_schema::token
  {
    public:

    struct _xsd_astroYear
    {
      typedef ::xml_schema::token base_;
    };

    // Constructors.
    //
    public:
    astroYear (const _xsd_astroYear::base_& );

    astroYear (const ::xercesc::DOMElement&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

    astroYear (const ::xercesc::DOMAttr&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

    astroYear (const ::std::basic_string< char >&,
               const ::xercesc::DOMElement*,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

    astroYear (const astroYear&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

    virtual astroYear*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;
  };

  class ucdType: public ::xml_schema::token
  {
    public:

    struct _xsd_ucdType
    {
      typedef ::xml_schema::token base_;
    };

    // Constructors.
    //
    public:
    ucdType (const _xsd_ucdType::base_& );

    ucdType (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    ucdType (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    ucdType (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    ucdType (const ucdType&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    virtual ucdType*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;
  };

  class arrayDEF: public ::xml_schema::token
  {
    public:

    struct _xsd_arrayDEF
    {
      typedef ::xml_schema::token base_;
    };

    // Constructors.
    //
    public:
    arrayDEF (const _xsd_arrayDEF::base_& );

    arrayDEF (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    arrayDEF (const ::xercesc::DOMAttr&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    arrayDEF (const ::std::basic_string< char >&,
              const ::xercesc::DOMElement*,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    arrayDEF (const arrayDEF&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    virtual arrayDEF*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;
  };

  class encodingType: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_encodingType
    {
      gzip,
      base64,
      dynamic,
      none
    };

    encodingType (_xsd_encodingType);

    encodingType (const ::xml_schema::nmtoken&);

    encodingType (const ::xercesc::DOMElement&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    encodingType (const ::xercesc::DOMAttr&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    encodingType (const ::std::basic_string< char >&,
                  const ::xercesc::DOMElement*,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    encodingType (const encodingType&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    virtual encodingType*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    encodingType&
    operator= (_xsd_encodingType);

    virtual
    operator _xsd_encodingType () const
    {
      return _xsd_encodingType_convert ();
    }

    protected:
    _xsd_encodingType
    _xsd_encodingType_convert () const;

    public:
    static const char* const _xsd_encodingType_literals_[4];
    static const _xsd_encodingType _xsd_encodingType_indexes_[4];
  };

  class dataType: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_dataType
    {
      boolean,
      bit,
      unsignedByte,
      short_,
      int_,
      long_,
      char_,
      unicodeChar,
      float_,
      double_,
      floatComplex,
      doubleComplex
    };

    dataType (_xsd_dataType);

    dataType (const ::xml_schema::nmtoken&);

    dataType (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    dataType (const ::xercesc::DOMAttr&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    dataType (const ::std::basic_string< char >&,
              const ::xercesc::DOMElement*,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    dataType (const dataType&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    virtual dataType*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    dataType&
    operator= (_xsd_dataType);

    virtual
    operator _xsd_dataType () const
    {
      return _xsd_dataType_convert ();
    }

    protected:
    _xsd_dataType
    _xsd_dataType_convert () const;

    public:
    static const char* const _xsd_dataType_literals_[12];
    static const _xsd_dataType _xsd_dataType_indexes_[12];
  };

  class precType: public ::xml_schema::token
  {
    public:

    struct _xsd_precType
    {
      typedef ::xml_schema::token base_;
    };

    // Constructors.
    //
    public:
    precType (const _xsd_precType::base_& );

    precType (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    precType (const ::xercesc::DOMAttr&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    precType (const ::std::basic_string< char >&,
              const ::xercesc::DOMElement*,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    precType (const precType&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    virtual precType*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;
  };

  class yesno: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_yesno
    {
      yes,
      no
    };

    yesno (_xsd_yesno);

    yesno (const ::xml_schema::nmtoken&);

    yesno (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    yesno (const ::xercesc::DOMAttr&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    yesno (const ::std::basic_string< char >&,
           const ::xercesc::DOMElement*,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    yesno (const yesno&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual yesno*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    yesno&
    operator= (_xsd_yesno);

    virtual
    operator _xsd_yesno () const
    {
      return _xsd_yesno_convert ();
    }

    protected:
    _xsd_yesno
    _xsd_yesno_convert () const;

    public:
    static const char* const _xsd_yesno_literals_[2];
    static const _xsd_yesno _xsd_yesno_indexes_[2];
  };

  class VOTABLE: public ::xml_schema::type
  {
    public:

    struct _xsd_VOTABLE
    {
      typedef ::xml_schema::type base_;
    };

    // DESCRIPTION
    // 
    public:
    struct DESCRIPTION
    {
      typedef ::votable::anyTEXT type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DESCRIPTION::container&
    DESCRIPTION () const;

    DESCRIPTION::container&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION::type&);

    void
    DESCRIPTION (const DESCRIPTION::container&);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION::type >);

    // DEFINITIONS
    // 
    public:
    struct DEFINITIONS
    {
      typedef ::votable::DEFINITIONS type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DEFINITIONS::container&
    DEFINITIONS () const;

    DEFINITIONS::container&
    DEFINITIONS ();

    void
    DEFINITIONS (const DEFINITIONS::type&);

    void
    DEFINITIONS (const DEFINITIONS::container&);

    void
    DEFINITIONS (::std::auto_ptr< DEFINITIONS::type >);

    // COOSYS
    // 
    public:
    struct COOSYS
    {
      typedef ::votable::COOSYS type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const COOSYS::container&
    COOSYS () const;

    COOSYS::container&
    COOSYS ();

    void
    COOSYS (const COOSYS::container&);

    // PARAM
    // 
    public:
    struct PARAM
    {
      typedef ::votable::PARAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const PARAM::container&
    PARAM () const;

    PARAM::container&
    PARAM ();

    void
    PARAM (const PARAM::container&);

    // INFO
    // 
    public:
    struct INFO
    {
      typedef ::votable::INFO type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const INFO::container&
    INFO () const;

    INFO::container&
    INFO ();

    void
    INFO (const INFO::container&);

    // RESOURCE
    // 
    public:
    struct RESOURCE
    {
      typedef ::votable::RESOURCE type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const RESOURCE::container&
    RESOURCE () const;

    RESOURCE::container&
    RESOURCE ();

    void
    RESOURCE (const RESOURCE::container&);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // version
    // 
    public:
    struct version
    {
      typedef ::votable::version type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const version::container&
    version () const;

    version::container&
    version ();

    void
    version (const version::type&);

    void
    version (const version::container&);

    void
    version (::std::auto_ptr< version::type >);

    // Constructors.
    //
    public:
    VOTABLE ();

    VOTABLE (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    VOTABLE (const VOTABLE&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    virtual VOTABLE*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< DESCRIPTION::type > _xsd_DESCRIPTION_;
    ::xsd::cxx::tree::optional< DEFINITIONS::type > _xsd_DEFINITIONS_;
    ::xsd::cxx::tree::sequence< COOSYS::type > _xsd_COOSYS_;
    ::xsd::cxx::tree::sequence< PARAM::type > _xsd_PARAM_;
    ::xsd::cxx::tree::sequence< INFO::type > _xsd_INFO_;
    ::xsd::cxx::tree::sequence< RESOURCE::type > _xsd_RESOURCE_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< version::type > _xsd_version_;
  };

  class RESOURCE: public ::xml_schema::type
  {
    public:

    struct _xsd_RESOURCE
    {
      typedef ::xml_schema::type base_;
    };

    // Workaround for g++ bug# 23206.
    //
    public:
    struct type;

    // DESCRIPTION
    // 
    public:
    struct DESCRIPTION
    {
      typedef ::votable::anyTEXT type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DESCRIPTION::container&
    DESCRIPTION () const;

    DESCRIPTION::container&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION::type&);

    void
    DESCRIPTION (const DESCRIPTION::container&);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION::type >);

    // INFO
    // 
    public:
    struct INFO
    {
      typedef ::votable::INFO type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const INFO::container&
    INFO () const;

    INFO::container&
    INFO ();

    void
    INFO (const INFO::container&);

    // COOSYS
    // 
    public:
    struct COOSYS
    {
      typedef ::votable::COOSYS type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const COOSYS::container&
    COOSYS () const;

    COOSYS::container&
    COOSYS ();

    void
    COOSYS (const COOSYS::container&);

    // PARAM
    // 
    public:
    struct PARAM
    {
      typedef ::votable::PARAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const PARAM::container&
    PARAM () const;

    PARAM::container&
    PARAM ();

    void
    PARAM (const PARAM::container&);

    // LINK
    // 
    public:
    struct LINK
    {
      typedef ::votable::LINK type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const LINK::container&
    LINK () const;

    LINK::container&
    LINK ();

    void
    LINK (const LINK::container&);

    // TABLE
    // 
    public:
    struct TABLE
    {
      typedef ::votable::TABLE type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const TABLE::container&
    TABLE () const;

    TABLE::container&
    TABLE ();

    void
    TABLE (const TABLE::container&);

    // RESOURCE
    // 
    public:
    struct RESOURCE1
    {
      typedef ::votable::RESOURCE type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const RESOURCE1::container&
    RESOURCE1 () const;

    RESOURCE1::container&
    RESOURCE1 ();

    void
    RESOURCE1 (const RESOURCE1::container&);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const name::container&
    name () const;

    name::container&
    name ();

    void
    name (const name::type&);

    void
    name (const name::container&);

    void
    name (::std::auto_ptr< name::type >);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // utype
    // 
    public:
    struct utype
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const utype::container&
    utype () const;

    utype::container&
    utype ();

    void
    utype (const utype::type&);

    void
    utype (const utype::container&);

    void
    utype (::std::auto_ptr< utype::type >);

    // type
    // 
    public:
    struct type
    {
      typedef ::votable::type type_;
      typedef ::xsd::cxx::tree::traits< type_, char > traits;

      static const type_&
      default_value ();

      private:
      static const type_ default_value_;
    };

    const type::type_&
    type () const;

    type::type_&
    type ();

    void
    type (const type::type_&);

    void
    type (::std::auto_ptr< type::type_ >);

    // Constructors.
    //
    public:
    RESOURCE ();

    RESOURCE (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    RESOURCE (const RESOURCE&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    virtual RESOURCE*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< DESCRIPTION::type > _xsd_DESCRIPTION_;
    ::xsd::cxx::tree::sequence< INFO::type > _xsd_INFO_;
    ::xsd::cxx::tree::sequence< COOSYS::type > _xsd_COOSYS_;
    ::xsd::cxx::tree::sequence< PARAM::type > _xsd_PARAM_;
    ::xsd::cxx::tree::sequence< LINK::type > _xsd_LINK_;
    ::xsd::cxx::tree::sequence< TABLE::type > _xsd_TABLE_;
    ::xsd::cxx::tree::sequence< RESOURCE1::type > _xsd_RESOURCE1_;
    ::xsd::cxx::tree::optional< name::type > _xsd_name_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< utype::type > _xsd_utype_;
    ::xsd::cxx::tree::one< type::type_ > _xsd_type_;
  };

  class DEFINITIONS: public ::xml_schema::type
  {
    public:

    struct _xsd_DEFINITIONS
    {
      typedef ::xml_schema::type base_;
    };

    // COOSYS
    // 
    public:
    struct COOSYS
    {
      typedef ::votable::COOSYS type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const COOSYS::container&
    COOSYS () const;

    COOSYS::container&
    COOSYS ();

    void
    COOSYS (const COOSYS::container&);

    // PARAM
    // 
    public:
    struct PARAM
    {
      typedef ::votable::PARAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const PARAM::container&
    PARAM () const;

    PARAM::container&
    PARAM ();

    void
    PARAM (const PARAM::container&);

    // Constructors.
    //
    public:
    DEFINITIONS ();

    DEFINITIONS (const ::xercesc::DOMElement&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

    DEFINITIONS (const DEFINITIONS&,
                 ::xml_schema::flags = 0,
                 ::xml_schema::type* = 0);

    virtual DEFINITIONS*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::sequence< COOSYS::type > _xsd_COOSYS_;
    ::xsd::cxx::tree::sequence< PARAM::type > _xsd_PARAM_;
  };

  class INFO: public ::xml_schema::string
  {
    public:

    struct _xsd_INFO
    {
      typedef ::xml_schema::string base_;
    };

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const name::type&
    name () const;

    name::type&
    name ();

    void
    name (const name::type&);

    void
    name (::std::auto_ptr< name::type >);

    // value
    // 
    public:
    struct value
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const value::type&
    value () const;

    value::type&
    value ();

    void
    value (const value::type&);

    void
    value (::std::auto_ptr< value::type >);

    // Constructors.
    //
    public:
    INFO (const _xsd_INFO::base_& ,
          const name::type&,
          const value::type&);

    INFO (const ::xercesc::DOMElement&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    INFO (const INFO&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    virtual INFO*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::one< name::type > _xsd_name_;
    ::xsd::cxx::tree::one< value::type > _xsd_value_;
  };

  class PARAM: public ::xml_schema::type
  {
    public:

    struct _xsd_PARAM
    {
      typedef ::xml_schema::type base_;
    };

    // DESCRIPTION
    // 
    public:
    struct DESCRIPTION
    {
      typedef ::votable::anyTEXT type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DESCRIPTION::container&
    DESCRIPTION () const;

    DESCRIPTION::container&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION::type&);

    void
    DESCRIPTION (const DESCRIPTION::container&);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION::type >);

    // VALUES
    // 
    public:
    struct VALUES
    {
      typedef ::votable::VALUES type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const VALUES::container&
    VALUES () const;

    VALUES::container&
    VALUES ();

    void
    VALUES (const VALUES::type&);

    void
    VALUES (const VALUES::container&);

    void
    VALUES (::std::auto_ptr< VALUES::type >);

    // LINK
    // 
    public:
    struct LINK
    {
      typedef ::votable::LINK type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const LINK::container&
    LINK () const;

    LINK::container&
    LINK ();

    void
    LINK (const LINK::container&);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // unit
    // 
    public:
    struct unit
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const unit::container&
    unit () const;

    unit::container&
    unit ();

    void
    unit (const unit::type&);

    void
    unit (const unit::container&);

    void
    unit (::std::auto_ptr< unit::type >);

    // datatype
    // 
    public:
    struct datatype
    {
      typedef ::votable::dataType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const datatype::type&
    datatype () const;

    datatype::type&
    datatype ();

    void
    datatype (const datatype::type&);

    void
    datatype (::std::auto_ptr< datatype::type >);

    // precision
    // 
    public:
    struct precision
    {
      typedef ::votable::precType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const precision::container&
    precision () const;

    precision::container&
    precision ();

    void
    precision (const precision::type&);

    void
    precision (const precision::container&);

    void
    precision (::std::auto_ptr< precision::type >);

    // width
    // 
    public:
    struct width
    {
      typedef ::xml_schema::positive_integer type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const width::container&
    width () const;

    width::container&
    width ();

    void
    width (const width::type&);

    void
    width (const width::container&);

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ref::container&
    ref () const;

    ref::container&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (const ref::container&);

    void
    ref (::std::auto_ptr< ref::type >);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const name::type&
    name () const;

    name::type&
    name ();

    void
    name (const name::type&);

    void
    name (::std::auto_ptr< name::type >);

    // ucd
    // 
    public:
    struct ucd
    {
      typedef ::votable::ucdType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ucd::container&
    ucd () const;

    ucd::container&
    ucd ();

    void
    ucd (const ucd::type&);

    void
    ucd (const ucd::container&);

    void
    ucd (::std::auto_ptr< ucd::type >);

    // utype
    // 
    public:
    struct utype
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const utype::container&
    utype () const;

    utype::container&
    utype ();

    void
    utype (const utype::type&);

    void
    utype (const utype::container&);

    void
    utype (::std::auto_ptr< utype::type >);

    // value
    // 
    public:
    struct value
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const value::type&
    value () const;

    value::type&
    value ();

    void
    value (const value::type&);

    void
    value (::std::auto_ptr< value::type >);

    // arraysize
    // 
    public:
    struct arraysize
    {
      typedef ::votable::arrayDEF type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const arraysize::container&
    arraysize () const;

    arraysize::container&
    arraysize ();

    void
    arraysize (const arraysize::type&);

    void
    arraysize (const arraysize::container&);

    void
    arraysize (::std::auto_ptr< arraysize::type >);

    // Constructors.
    //
    public:
    PARAM (const datatype::type&,
           const name::type&,
           const value::type&);

    PARAM (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    PARAM (const PARAM&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual PARAM*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< DESCRIPTION::type > _xsd_DESCRIPTION_;
    ::xsd::cxx::tree::optional< VALUES::type > _xsd_VALUES_;
    ::xsd::cxx::tree::sequence< LINK::type > _xsd_LINK_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< unit::type > _xsd_unit_;
    ::xsd::cxx::tree::one< datatype::type > _xsd_datatype_;
    ::xsd::cxx::tree::optional< precision::type > _xsd_precision_;
    ::xsd::cxx::tree::optional< width::type > _xsd_width_;
    ::xsd::cxx::tree::optional< ref::type > _xsd_ref_;
    ::xsd::cxx::tree::one< name::type > _xsd_name_;
    ::xsd::cxx::tree::optional< ucd::type > _xsd_ucd_;
    ::xsd::cxx::tree::optional< utype::type > _xsd_utype_;
    ::xsd::cxx::tree::one< value::type > _xsd_value_;
    ::xsd::cxx::tree::optional< arraysize::type > _xsd_arraysize_;
  };

  class TABLE: public ::xml_schema::type
  {
    public:

    struct _xsd_TABLE
    {
      typedef ::xml_schema::type base_;
    };

    // DESCRIPTION
    // 
    public:
    struct DESCRIPTION
    {
      typedef ::votable::anyTEXT type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DESCRIPTION::container&
    DESCRIPTION () const;

    DESCRIPTION::container&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION::type&);

    void
    DESCRIPTION (const DESCRIPTION::container&);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION::type >);

    // FIELD
    // 
    public:
    struct FIELD
    {
      typedef ::votable::FIELD type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const FIELD::container&
    FIELD () const;

    FIELD::container&
    FIELD ();

    void
    FIELD (const FIELD::container&);

    // PARAM
    // 
    public:
    struct PARAM
    {
      typedef ::votable::PARAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const PARAM::container&
    PARAM () const;

    PARAM::container&
    PARAM ();

    void
    PARAM (const PARAM::container&);

    // GROUP
    // 
    public:
    struct GROUP
    {
      typedef ::votable::GROUP type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const GROUP::container&
    GROUP () const;

    GROUP::container&
    GROUP ();

    void
    GROUP (const GROUP::container&);

    // LINK
    // 
    public:
    struct LINK
    {
      typedef ::votable::LINK type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const LINK::container&
    LINK () const;

    LINK::container&
    LINK ();

    void
    LINK (const LINK::container&);

    // DATA
    // 
    public:
    struct DATA
    {
      typedef ::votable::DATA type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DATA::container&
    DATA () const;

    DATA::container&
    DATA ();

    void
    DATA (const DATA::type&);

    void
    DATA (const DATA::container&);

    void
    DATA (::std::auto_ptr< DATA::type >);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const name::container&
    name () const;

    name::container&
    name ();

    void
    name (const name::type&);

    void
    name (const name::container&);

    void
    name (::std::auto_ptr< name::type >);

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ref::container&
    ref () const;

    ref::container&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (const ref::container&);

    void
    ref (::std::auto_ptr< ref::type >);

    // ucd
    // 
    public:
    struct ucd
    {
      typedef ::votable::ucdType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ucd::container&
    ucd () const;

    ucd::container&
    ucd ();

    void
    ucd (const ucd::type&);

    void
    ucd (const ucd::container&);

    void
    ucd (::std::auto_ptr< ucd::type >);

    // utype
    // 
    public:
    struct utype
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const utype::container&
    utype () const;

    utype::container&
    utype ();

    void
    utype (const utype::type&);

    void
    utype (const utype::container&);

    void
    utype (::std::auto_ptr< utype::type >);

    // nrows
    // 
    public:
    struct nrows
    {
      typedef ::xml_schema::non_negative_integer type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const nrows::container&
    nrows () const;

    nrows::container&
    nrows ();

    void
    nrows (const nrows::type&);

    void
    nrows (const nrows::container&);

    // Constructors.
    //
    public:
    TABLE ();

    TABLE (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    TABLE (const TABLE&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual TABLE*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< DESCRIPTION::type > _xsd_DESCRIPTION_;
    ::xsd::cxx::tree::sequence< FIELD::type > _xsd_FIELD_;
    ::xsd::cxx::tree::sequence< PARAM::type > _xsd_PARAM_;
    ::xsd::cxx::tree::sequence< GROUP::type > _xsd_GROUP_;
    ::xsd::cxx::tree::sequence< LINK::type > _xsd_LINK_;
    ::xsd::cxx::tree::optional< DATA::type > _xsd_DATA_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< name::type > _xsd_name_;
    ::xsd::cxx::tree::optional< ref::type > _xsd_ref_;
    ::xsd::cxx::tree::optional< ucd::type > _xsd_ucd_;
    ::xsd::cxx::tree::optional< utype::type > _xsd_utype_;
    ::xsd::cxx::tree::optional< nrows::type > _xsd_nrows_;
  };

  class FIELD: public ::xml_schema::type
  {
    public:

    struct _xsd_FIELD
    {
      typedef ::xml_schema::type base_;
    };

    // Workaround for g++ bug# 23206.
    //
    public:
    struct type;

    // DESCRIPTION
    // 
    public:
    struct DESCRIPTION
    {
      typedef ::votable::anyTEXT type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DESCRIPTION::container&
    DESCRIPTION () const;

    DESCRIPTION::container&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION::type&);

    void
    DESCRIPTION (const DESCRIPTION::container&);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION::type >);

    // VALUES
    // 
    public:
    struct VALUES
    {
      typedef ::votable::VALUES type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const VALUES::container&
    VALUES () const;

    VALUES::container&
    VALUES ();

    void
    VALUES (const VALUES::type&);

    void
    VALUES (const VALUES::container&);

    void
    VALUES (::std::auto_ptr< VALUES::type >);

    // LINK
    // 
    public:
    struct LINK
    {
      typedef ::votable::LINK type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const LINK::container&
    LINK () const;

    LINK::container&
    LINK ();

    void
    LINK (const LINK::container&);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // unit
    // 
    public:
    struct unit
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const unit::container&
    unit () const;

    unit::container&
    unit ();

    void
    unit (const unit::type&);

    void
    unit (const unit::container&);

    void
    unit (::std::auto_ptr< unit::type >);

    // datatype
    // 
    public:
    struct datatype
    {
      typedef ::votable::dataType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const datatype::type&
    datatype () const;

    datatype::type&
    datatype ();

    void
    datatype (const datatype::type&);

    void
    datatype (::std::auto_ptr< datatype::type >);

    // precision
    // 
    public:
    struct precision
    {
      typedef ::votable::precType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const precision::container&
    precision () const;

    precision::container&
    precision ();

    void
    precision (const precision::type&);

    void
    precision (const precision::container&);

    void
    precision (::std::auto_ptr< precision::type >);

    // width
    // 
    public:
    struct width
    {
      typedef ::xml_schema::positive_integer type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const width::container&
    width () const;

    width::container&
    width ();

    void
    width (const width::type&);

    void
    width (const width::container&);

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ref::container&
    ref () const;

    ref::container&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (const ref::container&);

    void
    ref (::std::auto_ptr< ref::type >);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const name::type&
    name () const;

    name::type&
    name ();

    void
    name (const name::type&);

    void
    name (::std::auto_ptr< name::type >);

    // ucd
    // 
    public:
    struct ucd
    {
      typedef ::votable::ucdType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ucd::container&
    ucd () const;

    ucd::container&
    ucd ();

    void
    ucd (const ucd::type&);

    void
    ucd (const ucd::container&);

    void
    ucd (::std::auto_ptr< ucd::type >);

    // utype
    // 
    public:
    struct utype
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const utype::container&
    utype () const;

    utype::container&
    utype ();

    void
    utype (const utype::type&);

    void
    utype (const utype::container&);

    void
    utype (::std::auto_ptr< utype::type >);

    // arraysize
    // 
    public:
    struct arraysize
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const arraysize::container&
    arraysize () const;

    arraysize::container&
    arraysize ();

    void
    arraysize (const arraysize::type&);

    void
    arraysize (const arraysize::container&);

    void
    arraysize (::std::auto_ptr< arraysize::type >);

    // type
    // 
    public:
    struct type
    {
      typedef ::votable::type1 type_;
      typedef ::xsd::cxx::tree::traits< type_, char > traits;
      typedef ::xsd::cxx::tree::optional< type_ > container;
    };

    const type::container&
    type () const;

    type::container&
    type ();

    void
    type (const type::type_&);

    void
    type (const type::container&);

    void
    type (::std::auto_ptr< type::type_ >);

    // Constructors.
    //
    public:
    FIELD (const datatype::type&,
           const name::type&);

    FIELD (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    FIELD (const FIELD&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual FIELD*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< DESCRIPTION::type > _xsd_DESCRIPTION_;
    ::xsd::cxx::tree::optional< VALUES::type > _xsd_VALUES_;
    ::xsd::cxx::tree::sequence< LINK::type > _xsd_LINK_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< unit::type > _xsd_unit_;
    ::xsd::cxx::tree::one< datatype::type > _xsd_datatype_;
    ::xsd::cxx::tree::optional< precision::type > _xsd_precision_;
    ::xsd::cxx::tree::optional< width::type > _xsd_width_;
    ::xsd::cxx::tree::optional< ref::type > _xsd_ref_;
    ::xsd::cxx::tree::one< name::type > _xsd_name_;
    ::xsd::cxx::tree::optional< ucd::type > _xsd_ucd_;
    ::xsd::cxx::tree::optional< utype::type > _xsd_utype_;
    ::xsd::cxx::tree::optional< arraysize::type > _xsd_arraysize_;
    ::xsd::cxx::tree::optional< type::type_ > _xsd_type_;
  };

  class GROUP: public ::xml_schema::type
  {
    public:

    struct _xsd_GROUP
    {
      typedef ::xml_schema::type base_;
    };

    // DESCRIPTION
    // 
    public:
    struct DESCRIPTION
    {
      typedef ::votable::anyTEXT type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const DESCRIPTION::container&
    DESCRIPTION () const;

    DESCRIPTION::container&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION::type&);

    void
    DESCRIPTION (const DESCRIPTION::container&);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION::type >);

    // FIELDref
    // 
    public:
    struct FIELDref
    {
      typedef ::votable::FIELDref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const FIELDref::container&
    FIELDref () const;

    FIELDref::container&
    FIELDref ();

    void
    FIELDref (const FIELDref::container&);

    // PARAMref
    // 
    public:
    struct PARAMref
    {
      typedef ::votable::PARAMref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const PARAMref::container&
    PARAMref () const;

    PARAMref::container&
    PARAMref ();

    void
    PARAMref (const PARAMref::container&);

    // PARAM
    // 
    public:
    struct PARAM
    {
      typedef ::votable::PARAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const PARAM::container&
    PARAM () const;

    PARAM::container&
    PARAM ();

    void
    PARAM (const PARAM::container&);

    // GROUP
    // 
    public:
    struct GROUP1
    {
      typedef ::votable::GROUP type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const GROUP1::container&
    GROUP1 () const;

    GROUP1::container&
    GROUP1 ();

    void
    GROUP1 (const GROUP1::container&);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const name::container&
    name () const;

    name::container&
    name ();

    void
    name (const name::type&);

    void
    name (const name::container&);

    void
    name (::std::auto_ptr< name::type >);

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ref::container&
    ref () const;

    ref::container&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (const ref::container&);

    void
    ref (::std::auto_ptr< ref::type >);

    // ucd
    // 
    public:
    struct ucd
    {
      typedef ::votable::ucdType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ucd::container&
    ucd () const;

    ucd::container&
    ucd ();

    void
    ucd (const ucd::type&);

    void
    ucd (const ucd::container&);

    void
    ucd (::std::auto_ptr< ucd::type >);

    // utype
    // 
    public:
    struct utype
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const utype::container&
    utype () const;

    utype::container&
    utype ();

    void
    utype (const utype::type&);

    void
    utype (const utype::container&);

    void
    utype (::std::auto_ptr< utype::type >);

    // Constructors.
    //
    public:
    GROUP ();

    GROUP (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    GROUP (const GROUP&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual GROUP*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< DESCRIPTION::type > _xsd_DESCRIPTION_;
    ::xsd::cxx::tree::sequence< FIELDref::type > _xsd_FIELDref_;
    ::xsd::cxx::tree::sequence< PARAMref::type > _xsd_PARAMref_;
    ::xsd::cxx::tree::sequence< PARAM::type > _xsd_PARAM_;
    ::xsd::cxx::tree::sequence< GROUP1::type > _xsd_GROUP1_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< name::type > _xsd_name_;
    ::xsd::cxx::tree::optional< ref::type > _xsd_ref_;
    ::xsd::cxx::tree::optional< ucd::type > _xsd_ucd_;
    ::xsd::cxx::tree::optional< utype::type > _xsd_utype_;
  };

  class FIELDref: public ::xml_schema::type
  {
    public:

    struct _xsd_FIELDref
    {
      typedef ::xml_schema::type base_;
    };

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const ref::type&
    ref () const;

    ref::type&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (::std::auto_ptr< ref::type >);

    // Constructors.
    //
    public:
    FIELDref (const ref::type&);

    FIELDref (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    FIELDref (const FIELDref&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    virtual FIELDref*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< ref::type > _xsd_ref_;
  };

  class PARAMref: public ::xml_schema::type
  {
    public:

    struct _xsd_PARAMref
    {
      typedef ::xml_schema::type base_;
    };

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const ref::type&
    ref () const;

    ref::type&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (::std::auto_ptr< ref::type >);

    // Constructors.
    //
    public:
    PARAMref (const ref::type&);

    PARAMref (const ::xercesc::DOMElement&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    PARAMref (const PARAMref&,
              ::xml_schema::flags = 0,
              ::xml_schema::type* = 0);

    virtual PARAMref*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< ref::type > _xsd_ref_;
  };

  class VALUES: public ::xml_schema::type
  {
    public:

    struct _xsd_VALUES
    {
      typedef ::xml_schema::type base_;
    };

    // Workaround for g++ bug# 23206.
    //
    public:
    struct type;

    // MIN
    // 
    public:
    struct MIN
    {
      typedef ::votable::MIN type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const MIN::container&
    MIN () const;

    MIN::container&
    MIN ();

    void
    MIN (const MIN::type&);

    void
    MIN (const MIN::container&);

    void
    MIN (::std::auto_ptr< MIN::type >);

    // MAX
    // 
    public:
    struct MAX
    {
      typedef ::votable::MAX type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const MAX::container&
    MAX () const;

    MAX::container&
    MAX ();

    void
    MAX (const MAX::type&);

    void
    MAX (const MAX::container&);

    void
    MAX (::std::auto_ptr< MAX::type >);

    // OPTION
    // 
    public:
    struct OPTION
    {
      typedef ::votable::OPTION type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const OPTION::container&
    OPTION () const;

    OPTION::container&
    OPTION ();

    void
    OPTION (const OPTION::container&);

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // type
    // 
    public:
    struct type
    {
      typedef ::votable::type2 type_;
      typedef ::xsd::cxx::tree::traits< type_, char > traits;

      static const type_&
      default_value ();

      private:
      static const type_ default_value_;
    };

    const type::type_&
    type () const;

    type::type_&
    type ();

    void
    type (const type::type_&);

    void
    type (::std::auto_ptr< type::type_ >);

    // null
    // 
    public:
    struct null
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const null::container&
    null () const;

    null::container&
    null ();

    void
    null (const null::type&);

    void
    null (const null::container&);

    void
    null (::std::auto_ptr< null::type >);

    // ref
    // 
    public:
    struct ref
    {
      typedef ::xml_schema::idref type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ref::container&
    ref () const;

    ref::container&
    ref ();

    void
    ref (const ref::type&);

    void
    ref (const ref::container&);

    void
    ref (::std::auto_ptr< ref::type >);

    // Constructors.
    //
    public:
    VALUES ();

    VALUES (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    VALUES (const VALUES&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    virtual VALUES*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< MIN::type > _xsd_MIN_;
    ::xsd::cxx::tree::optional< MAX::type > _xsd_MAX_;
    ::xsd::cxx::tree::sequence< OPTION::type > _xsd_OPTION_;
    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::one< type::type_ > _xsd_type_;
    ::xsd::cxx::tree::optional< null::type > _xsd_null_;
    ::xsd::cxx::tree::optional< ref::type > _xsd_ref_;
  };

  class MIN: public ::xml_schema::type
  {
    public:

    struct _xsd_MIN
    {
      typedef ::xml_schema::type base_;
    };

    // value
    // 
    public:
    struct value
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const value::type&
    value () const;

    value::type&
    value ();

    void
    value (const value::type&);

    void
    value (::std::auto_ptr< value::type >);

    // inclusive
    // 
    public:
    struct inclusive
    {
      typedef ::votable::yesno type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;

      static const type&
      default_value ();

      private:
      static const type default_value_;
    };

    const inclusive::type&
    inclusive () const;

    inclusive::type&
    inclusive ();

    void
    inclusive (const inclusive::type&);

    void
    inclusive (::std::auto_ptr< inclusive::type >);

    // Constructors.
    //
    public:
    MIN (const value::type&);

    MIN (const ::xercesc::DOMElement&,
         ::xml_schema::flags = 0,
         ::xml_schema::type* = 0);

    MIN (const MIN&,
         ::xml_schema::flags = 0,
         ::xml_schema::type* = 0);

    virtual MIN*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< value::type > _xsd_value_;
    ::xsd::cxx::tree::one< inclusive::type > _xsd_inclusive_;
  };

  class MAX: public ::xml_schema::type
  {
    public:

    struct _xsd_MAX
    {
      typedef ::xml_schema::type base_;
    };

    // value
    // 
    public:
    struct value
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const value::type&
    value () const;

    value::type&
    value ();

    void
    value (const value::type&);

    void
    value (::std::auto_ptr< value::type >);

    // inclusive
    // 
    public:
    struct inclusive
    {
      typedef ::votable::yesno type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;

      static const type&
      default_value ();

      private:
      static const type default_value_;
    };

    const inclusive::type&
    inclusive () const;

    inclusive::type&
    inclusive ();

    void
    inclusive (const inclusive::type&);

    void
    inclusive (::std::auto_ptr< inclusive::type >);

    // Constructors.
    //
    public:
    MAX (const value::type&);

    MAX (const ::xercesc::DOMElement&,
         ::xml_schema::flags = 0,
         ::xml_schema::type* = 0);

    MAX (const MAX&,
         ::xml_schema::flags = 0,
         ::xml_schema::type* = 0);

    virtual MAX*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< value::type > _xsd_value_;
    ::xsd::cxx::tree::one< inclusive::type > _xsd_inclusive_;
  };

  class OPTION: public ::xml_schema::type
  {
    public:

    struct _xsd_OPTION
    {
      typedef ::xml_schema::type base_;
    };

    // OPTION
    // 
    public:
    struct OPTION1
    {
      typedef ::votable::OPTION type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const OPTION1::container&
    OPTION1 () const;

    OPTION1::container&
    OPTION1 ();

    void
    OPTION1 (const OPTION1::container&);

    // name
    // 
    public:
    struct name
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const name::container&
    name () const;

    name::container&
    name ();

    void
    name (const name::type&);

    void
    name (const name::container&);

    void
    name (::std::auto_ptr< name::type >);

    // value
    // 
    public:
    struct value
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const value::type&
    value () const;

    value::type&
    value ();

    void
    value (const value::type&);

    void
    value (::std::auto_ptr< value::type >);

    // Constructors.
    //
    public:
    OPTION (const value::type&);

    OPTION (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    OPTION (const OPTION&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    virtual OPTION*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::sequence< OPTION1::type > _xsd_OPTION1_;
    ::xsd::cxx::tree::optional< name::type > _xsd_name_;
    ::xsd::cxx::tree::one< value::type > _xsd_value_;
  };

  class LINK: public ::xml_schema::type
  {
    public:

    struct _xsd_LINK
    {
      typedef ::xml_schema::type base_;
    };

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const ID::container&
    ID () const;

    ID::container&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (const ID::container&);

    void
    ID (::std::auto_ptr< ID::type >);

    // content-role
    // 
    public:
    struct content_role
    {
      typedef ::votable::content_role type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const content_role::container&
    content_role () const;

    content_role::container&
    content_role ();

    void
    content_role (const content_role::type&);

    void
    content_role (const content_role::container&);

    void
    content_role (::std::auto_ptr< content_role::type >);

    // content-type
    // 
    public:
    struct content_type
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const content_type::container&
    content_type () const;

    content_type::container&
    content_type ();

    void
    content_type (const content_type::type&);

    void
    content_type (const content_type::container&);

    void
    content_type (::std::auto_ptr< content_type::type >);

    // title
    // 
    public:
    struct title
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const title::container&
    title () const;

    title::container&
    title ();

    void
    title (const title::type&);

    void
    title (const title::container&);

    void
    title (::std::auto_ptr< title::type >);

    // value
    // 
    public:
    struct value
    {
      typedef ::xml_schema::string type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const value::container&
    value () const;

    value::container&
    value ();

    void
    value (const value::type&);

    void
    value (const value::container&);

    void
    value (::std::auto_ptr< value::type >);

    // href
    // 
    public:
    struct href
    {
      typedef ::xml_schema::uri type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const href::container&
    href () const;

    href::container&
    href ();

    void
    href (const href::type&);

    void
    href (const href::container&);

    void
    href (::std::auto_ptr< href::type >);

    // gref
    // 
    public:
    struct gref
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const gref::container&
    gref () const;

    gref::container&
    gref ();

    void
    gref (const gref::type&);

    void
    gref (const gref::container&);

    void
    gref (::std::auto_ptr< gref::type >);

    // action
    // 
    public:
    struct action
    {
      typedef ::xml_schema::uri type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const action::container&
    action () const;

    action::container&
    action ();

    void
    action (const action::type&);

    void
    action (const action::container&);

    void
    action (::std::auto_ptr< action::type >);

    // Constructors.
    //
    public:
    LINK ();

    LINK (const ::xercesc::DOMElement&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    LINK (const LINK&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    virtual LINK*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< content_role::type > _xsd_content_role_;
    ::xsd::cxx::tree::optional< content_type::type > _xsd_content_type_;
    ::xsd::cxx::tree::optional< title::type > _xsd_title_;
    ::xsd::cxx::tree::optional< value::type > _xsd_value_;
    ::xsd::cxx::tree::optional< href::type > _xsd_href_;
    ::xsd::cxx::tree::optional< gref::type > _xsd_gref_;
    ::xsd::cxx::tree::optional< action::type > _xsd_action_;
  };

  class DATA: public ::xml_schema::type
  {
    public:

    struct _xsd_DATA
    {
      typedef ::xml_schema::type base_;
    };

    // TABLEDATA
    // 
    public:
    struct TABLEDATA
    {
      typedef ::votable::TABLEDATA type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const TABLEDATA::container&
    TABLEDATA () const;

    TABLEDATA::container&
    TABLEDATA ();

    void
    TABLEDATA (const TABLEDATA::type&);

    void
    TABLEDATA (const TABLEDATA::container&);

    void
    TABLEDATA (::std::auto_ptr< TABLEDATA::type >);

    // BINARY
    // 
    public:
    struct BINARY
    {
      typedef ::votable::BINARY type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const BINARY::container&
    BINARY () const;

    BINARY::container&
    BINARY ();

    void
    BINARY (const BINARY::type&);

    void
    BINARY (const BINARY::container&);

    void
    BINARY (::std::auto_ptr< BINARY::type >);

    // FITS
    // 
    public:
    struct FITS
    {
      typedef ::votable::FITS type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const FITS::container&
    FITS () const;

    FITS::container&
    FITS ();

    void
    FITS (const FITS::type&);

    void
    FITS (const FITS::container&);

    void
    FITS (::std::auto_ptr< FITS::type >);

    // Constructors.
    //
    public:
    DATA ();

    DATA (const ::xercesc::DOMElement&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    DATA (const DATA&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    virtual DATA*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< TABLEDATA::type > _xsd_TABLEDATA_;
    ::xsd::cxx::tree::optional< BINARY::type > _xsd_BINARY_;
    ::xsd::cxx::tree::optional< FITS::type > _xsd_FITS_;
  };

  class TABLEDATA: public ::xml_schema::type
  {
    public:

    struct _xsd_TABLEDATA
    {
      typedef ::xml_schema::type base_;
    };

    // TR
    // 
    public:
    struct TR
    {
      typedef ::votable::TR type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const TR::container&
    TR () const;

    TR::container&
    TR ();

    void
    TR (const TR::container&);

    // Constructors.
    //
    public:
    TABLEDATA ();

    TABLEDATA (const ::xercesc::DOMElement&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

    TABLEDATA (const TABLEDATA&,
               ::xml_schema::flags = 0,
               ::xml_schema::type* = 0);

    virtual TABLEDATA*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::sequence< TR::type > _xsd_TR_;
  };

  class TD: public ::xml_schema::string
  {
    public:

    struct _xsd_TD
    {
      typedef ::xml_schema::string base_;
    };

    // encoding
    // 
    public:
    struct encoding
    {
      typedef ::votable::encodingType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const encoding::container&
    encoding () const;

    encoding::container&
    encoding ();

    void
    encoding (const encoding::type&);

    void
    encoding (const encoding::container&);

    void
    encoding (::std::auto_ptr< encoding::type >);

    // Constructors.
    //
    public:
    TD (const _xsd_TD::base_& );

    TD (const ::xercesc::DOMElement&,
        ::xml_schema::flags = 0,
        ::xml_schema::type* = 0);

    TD (const TD&,
        ::xml_schema::flags = 0,
        ::xml_schema::type* = 0);

    virtual TD*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::optional< encoding::type > _xsd_encoding_;
  };

  class TR: public ::xml_schema::type
  {
    public:

    struct _xsd_TR
    {
      typedef ::xml_schema::type base_;
    };

    // TD
    // 
    public:
    struct TD
    {
      typedef ::votable::TD type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::sequence< type > container;
      typedef container::iterator iterator;
      typedef container::const_iterator const_iterator;
    };

    const TD::container&
    TD () const;

    TD::container&
    TD ();

    void
    TD (const TD::container&);

    // Constructors.
    //
    public:
    TR ();

    TR (const ::xercesc::DOMElement&,
        ::xml_schema::flags = 0,
        ::xml_schema::type* = 0);

    TR (const TR&,
        ::xml_schema::flags = 0,
        ::xml_schema::type* = 0);

    virtual TR*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::sequence< TD::type > _xsd_TD_;
  };

  class FITS: public ::xml_schema::type
  {
    public:

    struct _xsd_FITS
    {
      typedef ::xml_schema::type base_;
    };

    // STREAM
    // 
    public:
    struct STREAM
    {
      typedef ::votable::STREAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const STREAM::type&
    STREAM () const;

    STREAM::type&
    STREAM ();

    void
    STREAM (const STREAM::type&);

    void
    STREAM (::std::auto_ptr< STREAM::type >);

    // extnum
    // 
    public:
    struct extnum
    {
      typedef ::xml_schema::positive_integer type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const extnum::container&
    extnum () const;

    extnum::container&
    extnum ();

    void
    extnum (const extnum::type&);

    void
    extnum (const extnum::container&);

    // Constructors.
    //
    public:
    FITS (const STREAM::type&);

    FITS (const ::xercesc::DOMElement&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    FITS (const FITS&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    virtual FITS*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< STREAM::type > _xsd_STREAM_;
    ::xsd::cxx::tree::optional< extnum::type > _xsd_extnum_;
  };

  class BINARY: public ::xml_schema::type
  {
    public:

    struct _xsd_BINARY
    {
      typedef ::xml_schema::type base_;
    };

    // STREAM
    // 
    public:
    struct STREAM
    {
      typedef ::votable::STREAM type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const STREAM::type&
    STREAM () const;

    STREAM::type&
    STREAM ();

    void
    STREAM (const STREAM::type&);

    void
    STREAM (::std::auto_ptr< STREAM::type >);

    // Constructors.
    //
    public:
    BINARY (const STREAM::type&);

    BINARY (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    BINARY (const BINARY&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    virtual BINARY*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< STREAM::type > _xsd_STREAM_;
  };

  class STREAM: public ::xml_schema::string
  {
    public:

    struct _xsd_STREAM
    {
      typedef ::xml_schema::string base_;
    };

    // Workaround for g++ bug# 23206.
    //
    public:
    struct type;

    // type
    // 
    public:
    struct type
    {
      typedef ::votable::type3 type_;
      typedef ::xsd::cxx::tree::traits< type_, char > traits;

      static const type_&
      default_value ();

      private:
      static const type_ default_value_;
    };

    const type::type_&
    type () const;

    type::type_&
    type ();

    void
    type (const type::type_&);

    void
    type (::std::auto_ptr< type::type_ >);

    // href
    // 
    public:
    struct href
    {
      typedef ::xml_schema::uri type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const href::container&
    href () const;

    href::container&
    href ();

    void
    href (const href::type&);

    void
    href (const href::container&);

    void
    href (::std::auto_ptr< href::type >);

    // actuate
    // 
    public:
    struct actuate
    {
      typedef ::votable::actuate type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;

      static const type&
      default_value ();

      private:
      static const type default_value_;
    };

    const actuate::type&
    actuate () const;

    actuate::type&
    actuate ();

    void
    actuate (const actuate::type&);

    void
    actuate (::std::auto_ptr< actuate::type >);

    // encoding
    // 
    public:
    struct encoding
    {
      typedef ::votable::encodingType type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;

      static const type&
      default_value ();

      private:
      static const type default_value_;
    };

    const encoding::type&
    encoding () const;

    encoding::type&
    encoding ();

    void
    encoding (const encoding::type&);

    void
    encoding (::std::auto_ptr< encoding::type >);

    // expires
    // 
    public:
    struct expires
    {
      typedef ::xml_schema::date_time type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const expires::container&
    expires () const;

    expires::container&
    expires ();

    void
    expires (const expires::type&);

    void
    expires (const expires::container&);

    void
    expires (::std::auto_ptr< expires::type >);

    // rights
    // 
    public:
    struct rights
    {
      typedef ::xml_schema::token type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const rights::container&
    rights () const;

    rights::container&
    rights ();

    void
    rights (const rights::type&);

    void
    rights (const rights::container&);

    void
    rights (::std::auto_ptr< rights::type >);

    // Constructors.
    //
    public:
    STREAM (const _xsd_STREAM::base_& );

    STREAM (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    STREAM (const STREAM&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    virtual STREAM*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< type::type_ > _xsd_type_;
    ::xsd::cxx::tree::optional< href::type > _xsd_href_;
    ::xsd::cxx::tree::one< actuate::type > _xsd_actuate_;
    ::xsd::cxx::tree::one< encoding::type > _xsd_encoding_;
    ::xsd::cxx::tree::optional< expires::type > _xsd_expires_;
    ::xsd::cxx::tree::optional< rights::type > _xsd_rights_;
  };

  class COOSYS: public ::xml_schema::string
  {
    public:

    struct _xsd_COOSYS
    {
      typedef ::xml_schema::string base_;
    };

    // ID
    // 
    public:
    struct ID
    {
      typedef ::xml_schema::id type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
    };

    const ID::type&
    ID () const;

    ID::type&
    ID ();

    void
    ID (const ID::type&);

    void
    ID (::std::auto_ptr< ID::type >);

    // equinox
    // 
    public:
    struct equinox
    {
      typedef ::votable::astroYear type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const equinox::container&
    equinox () const;

    equinox::container&
    equinox ();

    void
    equinox (const equinox::type&);

    void
    equinox (const equinox::container&);

    void
    equinox (::std::auto_ptr< equinox::type >);

    // epoch
    // 
    public:
    struct epoch
    {
      typedef ::votable::astroYear type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;
      typedef ::xsd::cxx::tree::optional< type > container;
    };

    const epoch::container&
    epoch () const;

    epoch::container&
    epoch ();

    void
    epoch (const epoch::type&);

    void
    epoch (const epoch::container&);

    void
    epoch (::std::auto_ptr< epoch::type >);

    // system
    // 
    public:
    struct system
    {
      typedef ::votable::system type;
      typedef ::xsd::cxx::tree::traits< type, char > traits;

      static const type&
      default_value ();

      private:
      static const type default_value_;
    };

    const system::type&
    system () const;

    system::type&
    system ();

    void
    system (const system::type&);

    void
    system (::std::auto_ptr< system::type >);

    // Constructors.
    //
    public:
    COOSYS (const _xsd_COOSYS::base_& ,
            const ID::type&);

    COOSYS (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    COOSYS (const COOSYS&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    virtual COOSYS*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    // Implementation.
    //
    private:
    void
    parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

    ::xsd::cxx::tree::one< ID::type > _xsd_ID_;
    ::xsd::cxx::tree::optional< equinox::type > _xsd_equinox_;
    ::xsd::cxx::tree::optional< epoch::type > _xsd_epoch_;
    ::xsd::cxx::tree::one< system::type > _xsd_system_;
  };

  class version: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_version
    {
      cxx_1_1
    };

    version (_xsd_version);

    version (const ::xml_schema::nmtoken&);

    version (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    version (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    version (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    version (const version&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    virtual version*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    version&
    operator= (_xsd_version);

    virtual
    operator _xsd_version () const
    {
      return _xsd_version_convert ();
    }

    protected:
    _xsd_version
    _xsd_version_convert () const;

    public:
    static const char* const _xsd_version_literals_[1];
    static const _xsd_version _xsd_version_indexes_[1];
  };

  class type: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_type
    {
      results,
      meta
    };

    type (_xsd_type);

    type (const ::xml_schema::nmtoken&);

    type (const ::xercesc::DOMElement&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    type (const ::xercesc::DOMAttr&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    type (const ::std::basic_string< char >&,
          const ::xercesc::DOMElement*,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    type (const type&,
          ::xml_schema::flags = 0,
          ::xml_schema::type* = 0);

    virtual type*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    type&
    operator= (_xsd_type);

    virtual
    operator _xsd_type () const
    {
      return _xsd_type_convert ();
    }

    protected:
    _xsd_type
    _xsd_type_convert () const;

    public:
    static const char* const _xsd_type_literals_[2];
    static const _xsd_type _xsd_type_indexes_[2];
  };

  class type1: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_type1
    {
      hidden,
      no_query,
      trigger,
      location
    };

    type1 (_xsd_type1);

    type1 (const ::xml_schema::nmtoken&);

    type1 (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type1 (const ::xercesc::DOMAttr&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type1 (const ::std::basic_string< char >&,
           const ::xercesc::DOMElement*,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type1 (const type1&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual type1*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    type1&
    operator= (_xsd_type1);

    virtual
    operator _xsd_type1 () const
    {
      return _xsd_type1_convert ();
    }

    protected:
    _xsd_type1
    _xsd_type1_convert () const;

    public:
    static const char* const _xsd_type1_literals_[4];
    static const _xsd_type1 _xsd_type1_indexes_[4];
  };

  class type2: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_type2
    {
      legal,
      actual
    };

    type2 (_xsd_type2);

    type2 (const ::xml_schema::nmtoken&);

    type2 (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type2 (const ::xercesc::DOMAttr&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type2 (const ::std::basic_string< char >&,
           const ::xercesc::DOMElement*,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type2 (const type2&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual type2*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    type2&
    operator= (_xsd_type2);

    virtual
    operator _xsd_type2 () const
    {
      return _xsd_type2_convert ();
    }

    protected:
    _xsd_type2
    _xsd_type2_convert () const;

    public:
    static const char* const _xsd_type2_literals_[2];
    static const _xsd_type2 _xsd_type2_indexes_[2];
  };

  class content_role: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_content_role
    {
      query,
      hints,
      doc,
      location
    };

    content_role (_xsd_content_role);

    content_role (const ::xml_schema::nmtoken&);

    content_role (const ::xercesc::DOMElement&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    content_role (const ::xercesc::DOMAttr&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    content_role (const ::std::basic_string< char >&,
                  const ::xercesc::DOMElement*,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    content_role (const content_role&,
                  ::xml_schema::flags = 0,
                  ::xml_schema::type* = 0);

    virtual content_role*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    content_role&
    operator= (_xsd_content_role);

    virtual
    operator _xsd_content_role () const
    {
      return _xsd_content_role_convert ();
    }

    protected:
    _xsd_content_role
    _xsd_content_role_convert () const;

    public:
    static const char* const _xsd_content_role_literals_[4];
    static const _xsd_content_role _xsd_content_role_indexes_[4];
  };

  class type3: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_type3
    {
      locator,
      other
    };

    type3 (_xsd_type3);

    type3 (const ::xml_schema::nmtoken&);

    type3 (const ::xercesc::DOMElement&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type3 (const ::xercesc::DOMAttr&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type3 (const ::std::basic_string< char >&,
           const ::xercesc::DOMElement*,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    type3 (const type3&,
           ::xml_schema::flags = 0,
           ::xml_schema::type* = 0);

    virtual type3*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    type3&
    operator= (_xsd_type3);

    virtual
    operator _xsd_type3 () const
    {
      return _xsd_type3_convert ();
    }

    protected:
    _xsd_type3
    _xsd_type3_convert () const;

    public:
    static const char* const _xsd_type3_literals_[2];
    static const _xsd_type3 _xsd_type3_indexes_[2];
  };

  class actuate: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_actuate
    {
      onLoad,
      onRequest,
      other,
      none
    };

    actuate (_xsd_actuate);

    actuate (const ::xml_schema::nmtoken&);

    actuate (const ::xercesc::DOMElement&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    actuate (const ::xercesc::DOMAttr&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    actuate (const ::std::basic_string< char >&,
             const ::xercesc::DOMElement*,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    actuate (const actuate&,
             ::xml_schema::flags = 0,
             ::xml_schema::type* = 0);

    virtual actuate*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    actuate&
    operator= (_xsd_actuate);

    virtual
    operator _xsd_actuate () const
    {
      return _xsd_actuate_convert ();
    }

    protected:
    _xsd_actuate
    _xsd_actuate_convert () const;

    public:
    static const char* const _xsd_actuate_literals_[4];
    static const _xsd_actuate _xsd_actuate_indexes_[4];
  };

  class system: public ::xml_schema::nmtoken
  {
    public:
    enum _xsd_system
    {
      eq_FK4,
      eq_FK5,
      ICRS,
      ecl_FK4,
      ecl_FK5,
      galactic,
      supergalactic,
      xy,
      barycentric,
      geo_app
    };

    system (_xsd_system);

    system (const ::xml_schema::nmtoken&);

    system (const ::xercesc::DOMElement&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    system (const ::xercesc::DOMAttr&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    system (const ::std::basic_string< char >&,
            const ::xercesc::DOMElement*,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    system (const system&,
            ::xml_schema::flags = 0,
            ::xml_schema::type* = 0);

    virtual system*
    _clone (::xml_schema::flags = 0,
            ::xml_schema::type* = 0) const;

    system&
    operator= (_xsd_system);

    virtual
    operator _xsd_system () const
    {
      return _xsd_system_convert ();
    }

    protected:
    _xsd_system
    _xsd_system_convert () const;

    public:
    static const char* const _xsd_system_literals_[10];
    static const _xsd_system _xsd_system_indexes_[10];
  };
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace votable
{
  // Read from a URI or a local file.
  //

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::std::basic_string< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::std::basic_string< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::std::basic_string< char >&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


  // Read from std::istream.
  //

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream&,
            const ::std::basic_string< char >& id,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


  // Read from InputSource.
  //

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMInputSource&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMInputSource&,
            ::xsd::cxx::xml::error_handler< char >&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMInputSource&,
            ::xercesc::DOMErrorHandler&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());


  // Read from DOM.
  //

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMDocument&,
            ::xml_schema::flags = 0,
            const ::xsd::cxx::tree::properties< char >& = ::xsd::cxx::tree::properties< char > ());
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace votable
{
  void
  operator<< (::xercesc::DOMElement&,
              const anyTEXT&);

  void
  operator<< (::xercesc::DOMAttr&,
              const anyTEXT&);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const anyTEXT&);

  void
  operator<< (::xercesc::DOMElement&,
              const astroYear&);

  void
  operator<< (::xercesc::DOMAttr&,
              const astroYear&);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const astroYear&);

  void
  operator<< (::xercesc::DOMElement&,
              const ucdType&);

  void
  operator<< (::xercesc::DOMAttr&,
              const ucdType&);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const ucdType&);

  void
  operator<< (::xercesc::DOMElement&,
              const arrayDEF&);

  void
  operator<< (::xercesc::DOMAttr&,
              const arrayDEF&);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const arrayDEF&);

  void
  operator<< (::xercesc::DOMElement&,
              encodingType);

  void
  operator<< (::xercesc::DOMAttr&,
              encodingType);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              encodingType);

  void
  operator<< (::xercesc::DOMElement&,
              dataType);

  void
  operator<< (::xercesc::DOMAttr&,
              dataType);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              dataType);

  void
  operator<< (::xercesc::DOMElement&,
              const precType&);

  void
  operator<< (::xercesc::DOMAttr&,
              const precType&);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const precType&);

  void
  operator<< (::xercesc::DOMElement&,
              yesno);

  void
  operator<< (::xercesc::DOMAttr&,
              yesno);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              yesno);

  // Serialize to an existing DOM instance.
  //
  void
  VOTABLE_ (::xercesc::DOMDocument&,
            const ::votable::VOTABLE&,
            ::xml_schema::flags = 0);


  // Serialize to a new DOM instance.
  //
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
  VOTABLE_ (const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xml_schema::flags = 0);


  // Serialize to XMLFormatTarget.
  //
  void
  VOTABLE_ (::xercesc::XMLFormatTarget&,
            const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


  void
  VOTABLE_ (::xercesc::XMLFormatTarget&,
            const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

  void
  VOTABLE_ (::xercesc::XMLFormatTarget&,
            const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


  // Serialize to std::ostream.
  //
  void
  VOTABLE_ (::std::ostream&,
            const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


  void
  VOTABLE_ (::std::ostream&,
            const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xsd::cxx::xml::error_handler< char >&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);

  void
  VOTABLE_ (::std::ostream&,
            const ::votable::VOTABLE&, 
            const ::xsd::cxx::xml::dom::namespace_infomap< char >&,
            ::xercesc::DOMErrorHandler&,
            const ::std::basic_string< char >& = "UTF-8",
            ::xml_schema::flags = 0);


  void
  operator<< (::xercesc::DOMElement&,
              const VOTABLE&);

  void
  operator<< (::xercesc::DOMElement&,
              const RESOURCE&);

  void
  operator<< (::xercesc::DOMElement&,
              const DEFINITIONS&);

  void
  operator<< (::xercesc::DOMElement&,
              const INFO&);

  void
  operator<< (::xercesc::DOMElement&,
              const PARAM&);

  void
  operator<< (::xercesc::DOMElement&,
              const TABLE&);

  void
  operator<< (::xercesc::DOMElement&,
              const FIELD&);

  void
  operator<< (::xercesc::DOMElement&,
              const GROUP&);

  void
  operator<< (::xercesc::DOMElement&,
              const FIELDref&);

  void
  operator<< (::xercesc::DOMElement&,
              const PARAMref&);

  void
  operator<< (::xercesc::DOMElement&,
              const VALUES&);

  void
  operator<< (::xercesc::DOMElement&,
              const MIN&);

  void
  operator<< (::xercesc::DOMElement&,
              const MAX&);

  void
  operator<< (::xercesc::DOMElement&,
              const OPTION&);

  void
  operator<< (::xercesc::DOMElement&,
              const LINK&);

  void
  operator<< (::xercesc::DOMElement&,
              const DATA&);

  void
  operator<< (::xercesc::DOMElement&,
              const TABLEDATA&);

  void
  operator<< (::xercesc::DOMElement&,
              const TD&);

  void
  operator<< (::xercesc::DOMElement&,
              const TR&);

  void
  operator<< (::xercesc::DOMElement&,
              const FITS&);

  void
  operator<< (::xercesc::DOMElement&,
              const BINARY&);

  void
  operator<< (::xercesc::DOMElement&,
              const STREAM&);

  void
  operator<< (::xercesc::DOMElement&,
              const COOSYS&);

  void
  operator<< (::xercesc::DOMElement&,
              version);

  void
  operator<< (::xercesc::DOMAttr&,
              version);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              version);

  void
  operator<< (::xercesc::DOMElement&,
              type);

  void
  operator<< (::xercesc::DOMAttr&,
              type);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              type);

  void
  operator<< (::xercesc::DOMElement&,
              type1);

  void
  operator<< (::xercesc::DOMAttr&,
              type1);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              type1);

  void
  operator<< (::xercesc::DOMElement&,
              type2);

  void
  operator<< (::xercesc::DOMAttr&,
              type2);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              type2);

  void
  operator<< (::xercesc::DOMElement&,
              content_role);

  void
  operator<< (::xercesc::DOMAttr&,
              content_role);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              content_role);

  void
  operator<< (::xercesc::DOMElement&,
              type3);

  void
  operator<< (::xercesc::DOMAttr&,
              type3);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              type3);

  void
  operator<< (::xercesc::DOMElement&,
              actuate);

  void
  operator<< (::xercesc::DOMAttr&,
              actuate);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              actuate);

  void
  operator<< (::xercesc::DOMElement&,
              system);

  void
  operator<< (::xercesc::DOMAttr&,
              system);

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              system);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // VOTABLE1_1_HXX
