// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "votable1.1.hxx"

namespace votable
{
  // anyTEXT
  // 


  // astroYear
  // 


  // ucdType
  // 


  // arrayDEF
  // 


  // encodingType
  // 

  encodingType::
  encodingType (_xsd_encodingType v)
  : ::xml_schema::nmtoken (_xsd_encodingType_literals_[v])
  {
  }

  encodingType::
  encodingType (const ::xml_schema::nmtoken& _xsd_encodingType)
  : ::xml_schema::nmtoken (_xsd_encodingType)
  {
  }

  encodingType::
  encodingType (const encodingType& v,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  encodingType& encodingType::
  operator= (_xsd_encodingType v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_encodingType_literals_[v]);

    return *this;
  }


  // dataType
  // 

  dataType::
  dataType (_xsd_dataType v)
  : ::xml_schema::nmtoken (_xsd_dataType_literals_[v])
  {
  }

  dataType::
  dataType (const ::xml_schema::nmtoken& _xsd_dataType)
  : ::xml_schema::nmtoken (_xsd_dataType)
  {
  }

  dataType::
  dataType (const dataType& v,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  dataType& dataType::
  operator= (_xsd_dataType v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_dataType_literals_[v]);

    return *this;
  }


  // precType
  // 


  // yesno
  // 

  yesno::
  yesno (_xsd_yesno v)
  : ::xml_schema::nmtoken (_xsd_yesno_literals_[v])
  {
  }

  yesno::
  yesno (const ::xml_schema::nmtoken& _xsd_yesno)
  : ::xml_schema::nmtoken (_xsd_yesno)
  {
  }

  yesno::
  yesno (const yesno& v,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  yesno& yesno::
  operator= (_xsd_yesno v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_yesno_literals_[v]);

    return *this;
  }


  // VOTABLE
  // 

  const VOTABLE::DESCRIPTION::container& VOTABLE::
  DESCRIPTION () const
  {
    return this->_xsd_DESCRIPTION_;
  }

  VOTABLE::DESCRIPTION::container& VOTABLE::
  DESCRIPTION ()
  {
    return this->_xsd_DESCRIPTION_;
  }

  void VOTABLE::
  DESCRIPTION (const DESCRIPTION::type& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  void VOTABLE::
  DESCRIPTION (const DESCRIPTION::container& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_ = DESCRIPTION;
  }

  void VOTABLE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION::type > DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  const VOTABLE::DEFINITIONS::container& VOTABLE::
  DEFINITIONS () const
  {
    return this->_xsd_DEFINITIONS_;
  }

  VOTABLE::DEFINITIONS::container& VOTABLE::
  DEFINITIONS ()
  {
    return this->_xsd_DEFINITIONS_;
  }

  void VOTABLE::
  DEFINITIONS (const DEFINITIONS::type& DEFINITIONS)
  {
    this->_xsd_DEFINITIONS_.set (DEFINITIONS);
  }

  void VOTABLE::
  DEFINITIONS (const DEFINITIONS::container& DEFINITIONS)
  {
    this->_xsd_DEFINITIONS_ = DEFINITIONS;
  }

  void VOTABLE::
  DEFINITIONS (::std::auto_ptr< DEFINITIONS::type > DEFINITIONS)
  {
    this->_xsd_DEFINITIONS_.set (DEFINITIONS);
  }

  const VOTABLE::COOSYS::container& VOTABLE::
  COOSYS () const
  {
    return this->_xsd_COOSYS_;
  }

  VOTABLE::COOSYS::container& VOTABLE::
  COOSYS ()
  {
    return this->_xsd_COOSYS_;
  }

  void VOTABLE::
  COOSYS (const COOSYS::container& COOSYS)
  {
    this->_xsd_COOSYS_ = COOSYS;
  }

  const VOTABLE::PARAM::container& VOTABLE::
  PARAM () const
  {
    return this->_xsd_PARAM_;
  }

  VOTABLE::PARAM::container& VOTABLE::
  PARAM ()
  {
    return this->_xsd_PARAM_;
  }

  void VOTABLE::
  PARAM (const PARAM::container& PARAM)
  {
    this->_xsd_PARAM_ = PARAM;
  }

  const VOTABLE::INFO::container& VOTABLE::
  INFO () const
  {
    return this->_xsd_INFO_;
  }

  VOTABLE::INFO::container& VOTABLE::
  INFO ()
  {
    return this->_xsd_INFO_;
  }

  void VOTABLE::
  INFO (const INFO::container& INFO)
  {
    this->_xsd_INFO_ = INFO;
  }

  const VOTABLE::RESOURCE::container& VOTABLE::
  RESOURCE () const
  {
    return this->_xsd_RESOURCE_;
  }

  VOTABLE::RESOURCE::container& VOTABLE::
  RESOURCE ()
  {
    return this->_xsd_RESOURCE_;
  }

  void VOTABLE::
  RESOURCE (const RESOURCE::container& RESOURCE)
  {
    this->_xsd_RESOURCE_ = RESOURCE;
  }

  const VOTABLE::ID::container& VOTABLE::
  ID () const
  {
    return this->_xsd_ID_;
  }

  VOTABLE::ID::container& VOTABLE::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void VOTABLE::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void VOTABLE::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void VOTABLE::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const VOTABLE::version::container& VOTABLE::
  version () const
  {
    return this->_xsd_version_;
  }

  VOTABLE::version::container& VOTABLE::
  version ()
  {
    return this->_xsd_version_;
  }

  void VOTABLE::
  version (const version::type& version)
  {
    this->_xsd_version_.set (version);
  }

  void VOTABLE::
  version (const version::container& version)
  {
    this->_xsd_version_ = version;
  }

  void VOTABLE::
  version (::std::auto_ptr< version::type > version)
  {
    this->_xsd_version_.set (version);
  }


  // RESOURCE
  // 

  const RESOURCE::DESCRIPTION::container& RESOURCE::
  DESCRIPTION () const
  {
    return this->_xsd_DESCRIPTION_;
  }

  RESOURCE::DESCRIPTION::container& RESOURCE::
  DESCRIPTION ()
  {
    return this->_xsd_DESCRIPTION_;
  }

  void RESOURCE::
  DESCRIPTION (const DESCRIPTION::type& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  void RESOURCE::
  DESCRIPTION (const DESCRIPTION::container& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_ = DESCRIPTION;
  }

  void RESOURCE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION::type > DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  const RESOURCE::INFO::container& RESOURCE::
  INFO () const
  {
    return this->_xsd_INFO_;
  }

  RESOURCE::INFO::container& RESOURCE::
  INFO ()
  {
    return this->_xsd_INFO_;
  }

  void RESOURCE::
  INFO (const INFO::container& INFO)
  {
    this->_xsd_INFO_ = INFO;
  }

  const RESOURCE::COOSYS::container& RESOURCE::
  COOSYS () const
  {
    return this->_xsd_COOSYS_;
  }

  RESOURCE::COOSYS::container& RESOURCE::
  COOSYS ()
  {
    return this->_xsd_COOSYS_;
  }

  void RESOURCE::
  COOSYS (const COOSYS::container& COOSYS)
  {
    this->_xsd_COOSYS_ = COOSYS;
  }

  const RESOURCE::PARAM::container& RESOURCE::
  PARAM () const
  {
    return this->_xsd_PARAM_;
  }

  RESOURCE::PARAM::container& RESOURCE::
  PARAM ()
  {
    return this->_xsd_PARAM_;
  }

  void RESOURCE::
  PARAM (const PARAM::container& PARAM)
  {
    this->_xsd_PARAM_ = PARAM;
  }

  const RESOURCE::LINK::container& RESOURCE::
  LINK () const
  {
    return this->_xsd_LINK_;
  }

  RESOURCE::LINK::container& RESOURCE::
  LINK ()
  {
    return this->_xsd_LINK_;
  }

  void RESOURCE::
  LINK (const LINK::container& LINK)
  {
    this->_xsd_LINK_ = LINK;
  }

  const RESOURCE::TABLE::container& RESOURCE::
  TABLE () const
  {
    return this->_xsd_TABLE_;
  }

  RESOURCE::TABLE::container& RESOURCE::
  TABLE ()
  {
    return this->_xsd_TABLE_;
  }

  void RESOURCE::
  TABLE (const TABLE::container& TABLE)
  {
    this->_xsd_TABLE_ = TABLE;
  }

  const RESOURCE::RESOURCE1::container& RESOURCE::
  RESOURCE1 () const
  {
    return this->_xsd_RESOURCE1_;
  }

  RESOURCE::RESOURCE1::container& RESOURCE::
  RESOURCE1 ()
  {
    return this->_xsd_RESOURCE1_;
  }

  void RESOURCE::
  RESOURCE1 (const RESOURCE1::container& RESOURCE1)
  {
    this->_xsd_RESOURCE1_ = RESOURCE1;
  }

  const RESOURCE::name::container& RESOURCE::
  name () const
  {
    return this->_xsd_name_;
  }

  RESOURCE::name::container& RESOURCE::
  name ()
  {
    return this->_xsd_name_;
  }

  void RESOURCE::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void RESOURCE::
  name (const name::container& name)
  {
    this->_xsd_name_ = name;
  }

  void RESOURCE::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const RESOURCE::ID::container& RESOURCE::
  ID () const
  {
    return this->_xsd_ID_;
  }

  RESOURCE::ID::container& RESOURCE::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void RESOURCE::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void RESOURCE::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void RESOURCE::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const RESOURCE::utype::container& RESOURCE::
  utype () const
  {
    return this->_xsd_utype_;
  }

  RESOURCE::utype::container& RESOURCE::
  utype ()
  {
    return this->_xsd_utype_;
  }

  void RESOURCE::
  utype (const utype::type& utype)
  {
    this->_xsd_utype_.set (utype);
  }

  void RESOURCE::
  utype (const utype::container& utype)
  {
    this->_xsd_utype_ = utype;
  }

  void RESOURCE::
  utype (::std::auto_ptr< utype::type > utype)
  {
    this->_xsd_utype_.set (utype);
  }

  const RESOURCE::type::type_& RESOURCE::type::
  default_value ()
  {
    return default_value_;
  }

  const RESOURCE::type::type_& RESOURCE::
  type () const
  {
    return this->_xsd_type_.get ();
  }

  RESOURCE::type::type_& RESOURCE::
  type ()
  {
    return this->_xsd_type_.get ();
  }

  void RESOURCE::
  type (const type::type_& type)
  {
    this->_xsd_type_.set (type);
  }

  void RESOURCE::
  type (::std::auto_ptr< type::type_ > type)
  {
    this->_xsd_type_.set (type);
  }


  // DEFINITIONS
  // 

  const DEFINITIONS::COOSYS::container& DEFINITIONS::
  COOSYS () const
  {
    return this->_xsd_COOSYS_;
  }

  DEFINITIONS::COOSYS::container& DEFINITIONS::
  COOSYS ()
  {
    return this->_xsd_COOSYS_;
  }

  void DEFINITIONS::
  COOSYS (const COOSYS::container& COOSYS)
  {
    this->_xsd_COOSYS_ = COOSYS;
  }

  const DEFINITIONS::PARAM::container& DEFINITIONS::
  PARAM () const
  {
    return this->_xsd_PARAM_;
  }

  DEFINITIONS::PARAM::container& DEFINITIONS::
  PARAM ()
  {
    return this->_xsd_PARAM_;
  }

  void DEFINITIONS::
  PARAM (const PARAM::container& PARAM)
  {
    this->_xsd_PARAM_ = PARAM;
  }


  // INFO
  // 

  const INFO::ID::container& INFO::
  ID () const
  {
    return this->_xsd_ID_;
  }

  INFO::ID::container& INFO::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void INFO::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void INFO::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void INFO::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const INFO::name::type& INFO::
  name () const
  {
    return this->_xsd_name_.get ();
  }

  INFO::name::type& INFO::
  name ()
  {
    return this->_xsd_name_.get ();
  }

  void INFO::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void INFO::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const INFO::value::type& INFO::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  INFO::value::type& INFO::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void INFO::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void INFO::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }


  // PARAM
  // 

  const PARAM::DESCRIPTION::container& PARAM::
  DESCRIPTION () const
  {
    return this->_xsd_DESCRIPTION_;
  }

  PARAM::DESCRIPTION::container& PARAM::
  DESCRIPTION ()
  {
    return this->_xsd_DESCRIPTION_;
  }

  void PARAM::
  DESCRIPTION (const DESCRIPTION::type& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  void PARAM::
  DESCRIPTION (const DESCRIPTION::container& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_ = DESCRIPTION;
  }

  void PARAM::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION::type > DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  const PARAM::VALUES::container& PARAM::
  VALUES () const
  {
    return this->_xsd_VALUES_;
  }

  PARAM::VALUES::container& PARAM::
  VALUES ()
  {
    return this->_xsd_VALUES_;
  }

  void PARAM::
  VALUES (const VALUES::type& VALUES)
  {
    this->_xsd_VALUES_.set (VALUES);
  }

  void PARAM::
  VALUES (const VALUES::container& VALUES)
  {
    this->_xsd_VALUES_ = VALUES;
  }

  void PARAM::
  VALUES (::std::auto_ptr< VALUES::type > VALUES)
  {
    this->_xsd_VALUES_.set (VALUES);
  }

  const PARAM::LINK::container& PARAM::
  LINK () const
  {
    return this->_xsd_LINK_;
  }

  PARAM::LINK::container& PARAM::
  LINK ()
  {
    return this->_xsd_LINK_;
  }

  void PARAM::
  LINK (const LINK::container& LINK)
  {
    this->_xsd_LINK_ = LINK;
  }

  const PARAM::ID::container& PARAM::
  ID () const
  {
    return this->_xsd_ID_;
  }

  PARAM::ID::container& PARAM::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void PARAM::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void PARAM::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void PARAM::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const PARAM::unit::container& PARAM::
  unit () const
  {
    return this->_xsd_unit_;
  }

  PARAM::unit::container& PARAM::
  unit ()
  {
    return this->_xsd_unit_;
  }

  void PARAM::
  unit (const unit::type& unit)
  {
    this->_xsd_unit_.set (unit);
  }

  void PARAM::
  unit (const unit::container& unit)
  {
    this->_xsd_unit_ = unit;
  }

  void PARAM::
  unit (::std::auto_ptr< unit::type > unit)
  {
    this->_xsd_unit_.set (unit);
  }

  const PARAM::datatype::type& PARAM::
  datatype () const
  {
    return this->_xsd_datatype_.get ();
  }

  PARAM::datatype::type& PARAM::
  datatype ()
  {
    return this->_xsd_datatype_.get ();
  }

  void PARAM::
  datatype (const datatype::type& datatype)
  {
    this->_xsd_datatype_.set (datatype);
  }

  void PARAM::
  datatype (::std::auto_ptr< datatype::type > datatype)
  {
    this->_xsd_datatype_.set (datatype);
  }

  const PARAM::precision::container& PARAM::
  precision () const
  {
    return this->_xsd_precision_;
  }

  PARAM::precision::container& PARAM::
  precision ()
  {
    return this->_xsd_precision_;
  }

  void PARAM::
  precision (const precision::type& precision)
  {
    this->_xsd_precision_.set (precision);
  }

  void PARAM::
  precision (const precision::container& precision)
  {
    this->_xsd_precision_ = precision;
  }

  void PARAM::
  precision (::std::auto_ptr< precision::type > precision)
  {
    this->_xsd_precision_.set (precision);
  }

  const PARAM::width::container& PARAM::
  width () const
  {
    return this->_xsd_width_;
  }

  PARAM::width::container& PARAM::
  width ()
  {
    return this->_xsd_width_;
  }

  void PARAM::
  width (const width::type& width)
  {
    this->_xsd_width_.set (width);
  }

  void PARAM::
  width (const width::container& width)
  {
    this->_xsd_width_ = width;
  }

  const PARAM::ref::container& PARAM::
  ref () const
  {
    return this->_xsd_ref_;
  }

  PARAM::ref::container& PARAM::
  ref ()
  {
    return this->_xsd_ref_;
  }

  void PARAM::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void PARAM::
  ref (const ref::container& ref)
  {
    this->_xsd_ref_ = ref;
  }

  void PARAM::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }

  const PARAM::name::type& PARAM::
  name () const
  {
    return this->_xsd_name_.get ();
  }

  PARAM::name::type& PARAM::
  name ()
  {
    return this->_xsd_name_.get ();
  }

  void PARAM::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void PARAM::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const PARAM::ucd::container& PARAM::
  ucd () const
  {
    return this->_xsd_ucd_;
  }

  PARAM::ucd::container& PARAM::
  ucd ()
  {
    return this->_xsd_ucd_;
  }

  void PARAM::
  ucd (const ucd::type& ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  void PARAM::
  ucd (const ucd::container& ucd)
  {
    this->_xsd_ucd_ = ucd;
  }

  void PARAM::
  ucd (::std::auto_ptr< ucd::type > ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  const PARAM::utype::container& PARAM::
  utype () const
  {
    return this->_xsd_utype_;
  }

  PARAM::utype::container& PARAM::
  utype ()
  {
    return this->_xsd_utype_;
  }

  void PARAM::
  utype (const utype::type& utype)
  {
    this->_xsd_utype_.set (utype);
  }

  void PARAM::
  utype (const utype::container& utype)
  {
    this->_xsd_utype_ = utype;
  }

  void PARAM::
  utype (::std::auto_ptr< utype::type > utype)
  {
    this->_xsd_utype_.set (utype);
  }

  const PARAM::value::type& PARAM::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  PARAM::value::type& PARAM::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void PARAM::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void PARAM::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const PARAM::arraysize::container& PARAM::
  arraysize () const
  {
    return this->_xsd_arraysize_;
  }

  PARAM::arraysize::container& PARAM::
  arraysize ()
  {
    return this->_xsd_arraysize_;
  }

  void PARAM::
  arraysize (const arraysize::type& arraysize)
  {
    this->_xsd_arraysize_.set (arraysize);
  }

  void PARAM::
  arraysize (const arraysize::container& arraysize)
  {
    this->_xsd_arraysize_ = arraysize;
  }

  void PARAM::
  arraysize (::std::auto_ptr< arraysize::type > arraysize)
  {
    this->_xsd_arraysize_.set (arraysize);
  }


  // TABLE
  // 

  const TABLE::DESCRIPTION::container& TABLE::
  DESCRIPTION () const
  {
    return this->_xsd_DESCRIPTION_;
  }

  TABLE::DESCRIPTION::container& TABLE::
  DESCRIPTION ()
  {
    return this->_xsd_DESCRIPTION_;
  }

  void TABLE::
  DESCRIPTION (const DESCRIPTION::type& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  void TABLE::
  DESCRIPTION (const DESCRIPTION::container& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_ = DESCRIPTION;
  }

  void TABLE::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION::type > DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  const TABLE::FIELD::container& TABLE::
  FIELD () const
  {
    return this->_xsd_FIELD_;
  }

  TABLE::FIELD::container& TABLE::
  FIELD ()
  {
    return this->_xsd_FIELD_;
  }

  void TABLE::
  FIELD (const FIELD::container& FIELD)
  {
    this->_xsd_FIELD_ = FIELD;
  }

  const TABLE::PARAM::container& TABLE::
  PARAM () const
  {
    return this->_xsd_PARAM_;
  }

  TABLE::PARAM::container& TABLE::
  PARAM ()
  {
    return this->_xsd_PARAM_;
  }

  void TABLE::
  PARAM (const PARAM::container& PARAM)
  {
    this->_xsd_PARAM_ = PARAM;
  }

  const TABLE::GROUP::container& TABLE::
  GROUP () const
  {
    return this->_xsd_GROUP_;
  }

  TABLE::GROUP::container& TABLE::
  GROUP ()
  {
    return this->_xsd_GROUP_;
  }

  void TABLE::
  GROUP (const GROUP::container& GROUP)
  {
    this->_xsd_GROUP_ = GROUP;
  }

  const TABLE::LINK::container& TABLE::
  LINK () const
  {
    return this->_xsd_LINK_;
  }

  TABLE::LINK::container& TABLE::
  LINK ()
  {
    return this->_xsd_LINK_;
  }

  void TABLE::
  LINK (const LINK::container& LINK)
  {
    this->_xsd_LINK_ = LINK;
  }

  const TABLE::DATA::container& TABLE::
  DATA () const
  {
    return this->_xsd_DATA_;
  }

  TABLE::DATA::container& TABLE::
  DATA ()
  {
    return this->_xsd_DATA_;
  }

  void TABLE::
  DATA (const DATA::type& DATA)
  {
    this->_xsd_DATA_.set (DATA);
  }

  void TABLE::
  DATA (const DATA::container& DATA)
  {
    this->_xsd_DATA_ = DATA;
  }

  void TABLE::
  DATA (::std::auto_ptr< DATA::type > DATA)
  {
    this->_xsd_DATA_.set (DATA);
  }

  const TABLE::ID::container& TABLE::
  ID () const
  {
    return this->_xsd_ID_;
  }

  TABLE::ID::container& TABLE::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void TABLE::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void TABLE::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void TABLE::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const TABLE::name::container& TABLE::
  name () const
  {
    return this->_xsd_name_;
  }

  TABLE::name::container& TABLE::
  name ()
  {
    return this->_xsd_name_;
  }

  void TABLE::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void TABLE::
  name (const name::container& name)
  {
    this->_xsd_name_ = name;
  }

  void TABLE::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const TABLE::ref::container& TABLE::
  ref () const
  {
    return this->_xsd_ref_;
  }

  TABLE::ref::container& TABLE::
  ref ()
  {
    return this->_xsd_ref_;
  }

  void TABLE::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void TABLE::
  ref (const ref::container& ref)
  {
    this->_xsd_ref_ = ref;
  }

  void TABLE::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }

  const TABLE::ucd::container& TABLE::
  ucd () const
  {
    return this->_xsd_ucd_;
  }

  TABLE::ucd::container& TABLE::
  ucd ()
  {
    return this->_xsd_ucd_;
  }

  void TABLE::
  ucd (const ucd::type& ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  void TABLE::
  ucd (const ucd::container& ucd)
  {
    this->_xsd_ucd_ = ucd;
  }

  void TABLE::
  ucd (::std::auto_ptr< ucd::type > ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  const TABLE::utype::container& TABLE::
  utype () const
  {
    return this->_xsd_utype_;
  }

  TABLE::utype::container& TABLE::
  utype ()
  {
    return this->_xsd_utype_;
  }

  void TABLE::
  utype (const utype::type& utype)
  {
    this->_xsd_utype_.set (utype);
  }

  void TABLE::
  utype (const utype::container& utype)
  {
    this->_xsd_utype_ = utype;
  }

  void TABLE::
  utype (::std::auto_ptr< utype::type > utype)
  {
    this->_xsd_utype_.set (utype);
  }

  const TABLE::nrows::container& TABLE::
  nrows () const
  {
    return this->_xsd_nrows_;
  }

  TABLE::nrows::container& TABLE::
  nrows ()
  {
    return this->_xsd_nrows_;
  }

  void TABLE::
  nrows (const nrows::type& nrows)
  {
    this->_xsd_nrows_.set (nrows);
  }

  void TABLE::
  nrows (const nrows::container& nrows)
  {
    this->_xsd_nrows_ = nrows;
  }


  // FIELD
  // 

  const FIELD::DESCRIPTION::container& FIELD::
  DESCRIPTION () const
  {
    return this->_xsd_DESCRIPTION_;
  }

  FIELD::DESCRIPTION::container& FIELD::
  DESCRIPTION ()
  {
    return this->_xsd_DESCRIPTION_;
  }

  void FIELD::
  DESCRIPTION (const DESCRIPTION::type& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  void FIELD::
  DESCRIPTION (const DESCRIPTION::container& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_ = DESCRIPTION;
  }

  void FIELD::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION::type > DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  const FIELD::VALUES::container& FIELD::
  VALUES () const
  {
    return this->_xsd_VALUES_;
  }

  FIELD::VALUES::container& FIELD::
  VALUES ()
  {
    return this->_xsd_VALUES_;
  }

  void FIELD::
  VALUES (const VALUES::type& VALUES)
  {
    this->_xsd_VALUES_.set (VALUES);
  }

  void FIELD::
  VALUES (const VALUES::container& VALUES)
  {
    this->_xsd_VALUES_ = VALUES;
  }

  void FIELD::
  VALUES (::std::auto_ptr< VALUES::type > VALUES)
  {
    this->_xsd_VALUES_.set (VALUES);
  }

  const FIELD::LINK::container& FIELD::
  LINK () const
  {
    return this->_xsd_LINK_;
  }

  FIELD::LINK::container& FIELD::
  LINK ()
  {
    return this->_xsd_LINK_;
  }

  void FIELD::
  LINK (const LINK::container& LINK)
  {
    this->_xsd_LINK_ = LINK;
  }

  const FIELD::ID::container& FIELD::
  ID () const
  {
    return this->_xsd_ID_;
  }

  FIELD::ID::container& FIELD::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void FIELD::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void FIELD::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void FIELD::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const FIELD::unit::container& FIELD::
  unit () const
  {
    return this->_xsd_unit_;
  }

  FIELD::unit::container& FIELD::
  unit ()
  {
    return this->_xsd_unit_;
  }

  void FIELD::
  unit (const unit::type& unit)
  {
    this->_xsd_unit_.set (unit);
  }

  void FIELD::
  unit (const unit::container& unit)
  {
    this->_xsd_unit_ = unit;
  }

  void FIELD::
  unit (::std::auto_ptr< unit::type > unit)
  {
    this->_xsd_unit_.set (unit);
  }

  const FIELD::datatype::type& FIELD::
  datatype () const
  {
    return this->_xsd_datatype_.get ();
  }

  FIELD::datatype::type& FIELD::
  datatype ()
  {
    return this->_xsd_datatype_.get ();
  }

  void FIELD::
  datatype (const datatype::type& datatype)
  {
    this->_xsd_datatype_.set (datatype);
  }

  void FIELD::
  datatype (::std::auto_ptr< datatype::type > datatype)
  {
    this->_xsd_datatype_.set (datatype);
  }

  const FIELD::precision::container& FIELD::
  precision () const
  {
    return this->_xsd_precision_;
  }

  FIELD::precision::container& FIELD::
  precision ()
  {
    return this->_xsd_precision_;
  }

  void FIELD::
  precision (const precision::type& precision)
  {
    this->_xsd_precision_.set (precision);
  }

  void FIELD::
  precision (const precision::container& precision)
  {
    this->_xsd_precision_ = precision;
  }

  void FIELD::
  precision (::std::auto_ptr< precision::type > precision)
  {
    this->_xsd_precision_.set (precision);
  }

  const FIELD::width::container& FIELD::
  width () const
  {
    return this->_xsd_width_;
  }

  FIELD::width::container& FIELD::
  width ()
  {
    return this->_xsd_width_;
  }

  void FIELD::
  width (const width::type& width)
  {
    this->_xsd_width_.set (width);
  }

  void FIELD::
  width (const width::container& width)
  {
    this->_xsd_width_ = width;
  }

  const FIELD::ref::container& FIELD::
  ref () const
  {
    return this->_xsd_ref_;
  }

  FIELD::ref::container& FIELD::
  ref ()
  {
    return this->_xsd_ref_;
  }

  void FIELD::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void FIELD::
  ref (const ref::container& ref)
  {
    this->_xsd_ref_ = ref;
  }

  void FIELD::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }

  const FIELD::name::type& FIELD::
  name () const
  {
    return this->_xsd_name_.get ();
  }

  FIELD::name::type& FIELD::
  name ()
  {
    return this->_xsd_name_.get ();
  }

  void FIELD::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void FIELD::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const FIELD::ucd::container& FIELD::
  ucd () const
  {
    return this->_xsd_ucd_;
  }

  FIELD::ucd::container& FIELD::
  ucd ()
  {
    return this->_xsd_ucd_;
  }

  void FIELD::
  ucd (const ucd::type& ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  void FIELD::
  ucd (const ucd::container& ucd)
  {
    this->_xsd_ucd_ = ucd;
  }

  void FIELD::
  ucd (::std::auto_ptr< ucd::type > ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  const FIELD::utype::container& FIELD::
  utype () const
  {
    return this->_xsd_utype_;
  }

  FIELD::utype::container& FIELD::
  utype ()
  {
    return this->_xsd_utype_;
  }

  void FIELD::
  utype (const utype::type& utype)
  {
    this->_xsd_utype_.set (utype);
  }

  void FIELD::
  utype (const utype::container& utype)
  {
    this->_xsd_utype_ = utype;
  }

  void FIELD::
  utype (::std::auto_ptr< utype::type > utype)
  {
    this->_xsd_utype_.set (utype);
  }

  const FIELD::arraysize::container& FIELD::
  arraysize () const
  {
    return this->_xsd_arraysize_;
  }

  FIELD::arraysize::container& FIELD::
  arraysize ()
  {
    return this->_xsd_arraysize_;
  }

  void FIELD::
  arraysize (const arraysize::type& arraysize)
  {
    this->_xsd_arraysize_.set (arraysize);
  }

  void FIELD::
  arraysize (const arraysize::container& arraysize)
  {
    this->_xsd_arraysize_ = arraysize;
  }

  void FIELD::
  arraysize (::std::auto_ptr< arraysize::type > arraysize)
  {
    this->_xsd_arraysize_.set (arraysize);
  }

  const FIELD::type::container& FIELD::
  type () const
  {
    return this->_xsd_type_;
  }

  FIELD::type::container& FIELD::
  type ()
  {
    return this->_xsd_type_;
  }

  void FIELD::
  type (const type::type_& type)
  {
    this->_xsd_type_.set (type);
  }

  void FIELD::
  type (const type::container& type)
  {
    this->_xsd_type_ = type;
  }

  void FIELD::
  type (::std::auto_ptr< type::type_ > type)
  {
    this->_xsd_type_.set (type);
  }


  // GROUP
  // 

  const GROUP::DESCRIPTION::container& GROUP::
  DESCRIPTION () const
  {
    return this->_xsd_DESCRIPTION_;
  }

  GROUP::DESCRIPTION::container& GROUP::
  DESCRIPTION ()
  {
    return this->_xsd_DESCRIPTION_;
  }

  void GROUP::
  DESCRIPTION (const DESCRIPTION::type& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  void GROUP::
  DESCRIPTION (const DESCRIPTION::container& DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_ = DESCRIPTION;
  }

  void GROUP::
  DESCRIPTION (::std::auto_ptr< DESCRIPTION::type > DESCRIPTION)
  {
    this->_xsd_DESCRIPTION_.set (DESCRIPTION);
  }

  const GROUP::FIELDref::container& GROUP::
  FIELDref () const
  {
    return this->_xsd_FIELDref_;
  }

  GROUP::FIELDref::container& GROUP::
  FIELDref ()
  {
    return this->_xsd_FIELDref_;
  }

  void GROUP::
  FIELDref (const FIELDref::container& FIELDref)
  {
    this->_xsd_FIELDref_ = FIELDref;
  }

  const GROUP::PARAMref::container& GROUP::
  PARAMref () const
  {
    return this->_xsd_PARAMref_;
  }

  GROUP::PARAMref::container& GROUP::
  PARAMref ()
  {
    return this->_xsd_PARAMref_;
  }

  void GROUP::
  PARAMref (const PARAMref::container& PARAMref)
  {
    this->_xsd_PARAMref_ = PARAMref;
  }

  const GROUP::PARAM::container& GROUP::
  PARAM () const
  {
    return this->_xsd_PARAM_;
  }

  GROUP::PARAM::container& GROUP::
  PARAM ()
  {
    return this->_xsd_PARAM_;
  }

  void GROUP::
  PARAM (const PARAM::container& PARAM)
  {
    this->_xsd_PARAM_ = PARAM;
  }

  const GROUP::GROUP1::container& GROUP::
  GROUP1 () const
  {
    return this->_xsd_GROUP1_;
  }

  GROUP::GROUP1::container& GROUP::
  GROUP1 ()
  {
    return this->_xsd_GROUP1_;
  }

  void GROUP::
  GROUP1 (const GROUP1::container& GROUP1)
  {
    this->_xsd_GROUP1_ = GROUP1;
  }

  const GROUP::ID::container& GROUP::
  ID () const
  {
    return this->_xsd_ID_;
  }

  GROUP::ID::container& GROUP::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void GROUP::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void GROUP::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void GROUP::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const GROUP::name::container& GROUP::
  name () const
  {
    return this->_xsd_name_;
  }

  GROUP::name::container& GROUP::
  name ()
  {
    return this->_xsd_name_;
  }

  void GROUP::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void GROUP::
  name (const name::container& name)
  {
    this->_xsd_name_ = name;
  }

  void GROUP::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const GROUP::ref::container& GROUP::
  ref () const
  {
    return this->_xsd_ref_;
  }

  GROUP::ref::container& GROUP::
  ref ()
  {
    return this->_xsd_ref_;
  }

  void GROUP::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void GROUP::
  ref (const ref::container& ref)
  {
    this->_xsd_ref_ = ref;
  }

  void GROUP::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }

  const GROUP::ucd::container& GROUP::
  ucd () const
  {
    return this->_xsd_ucd_;
  }

  GROUP::ucd::container& GROUP::
  ucd ()
  {
    return this->_xsd_ucd_;
  }

  void GROUP::
  ucd (const ucd::type& ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  void GROUP::
  ucd (const ucd::container& ucd)
  {
    this->_xsd_ucd_ = ucd;
  }

  void GROUP::
  ucd (::std::auto_ptr< ucd::type > ucd)
  {
    this->_xsd_ucd_.set (ucd);
  }

  const GROUP::utype::container& GROUP::
  utype () const
  {
    return this->_xsd_utype_;
  }

  GROUP::utype::container& GROUP::
  utype ()
  {
    return this->_xsd_utype_;
  }

  void GROUP::
  utype (const utype::type& utype)
  {
    this->_xsd_utype_.set (utype);
  }

  void GROUP::
  utype (const utype::container& utype)
  {
    this->_xsd_utype_ = utype;
  }

  void GROUP::
  utype (::std::auto_ptr< utype::type > utype)
  {
    this->_xsd_utype_.set (utype);
  }


  // FIELDref
  // 

  const FIELDref::ref::type& FIELDref::
  ref () const
  {
    return this->_xsd_ref_.get ();
  }

  FIELDref::ref::type& FIELDref::
  ref ()
  {
    return this->_xsd_ref_.get ();
  }

  void FIELDref::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void FIELDref::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }


  // PARAMref
  // 

  const PARAMref::ref::type& PARAMref::
  ref () const
  {
    return this->_xsd_ref_.get ();
  }

  PARAMref::ref::type& PARAMref::
  ref ()
  {
    return this->_xsd_ref_.get ();
  }

  void PARAMref::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void PARAMref::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }


  // VALUES
  // 

  const VALUES::MIN::container& VALUES::
  MIN () const
  {
    return this->_xsd_MIN_;
  }

  VALUES::MIN::container& VALUES::
  MIN ()
  {
    return this->_xsd_MIN_;
  }

  void VALUES::
  MIN (const MIN::type& MIN)
  {
    this->_xsd_MIN_.set (MIN);
  }

  void VALUES::
  MIN (const MIN::container& MIN)
  {
    this->_xsd_MIN_ = MIN;
  }

  void VALUES::
  MIN (::std::auto_ptr< MIN::type > MIN)
  {
    this->_xsd_MIN_.set (MIN);
  }

  const VALUES::MAX::container& VALUES::
  MAX () const
  {
    return this->_xsd_MAX_;
  }

  VALUES::MAX::container& VALUES::
  MAX ()
  {
    return this->_xsd_MAX_;
  }

  void VALUES::
  MAX (const MAX::type& MAX)
  {
    this->_xsd_MAX_.set (MAX);
  }

  void VALUES::
  MAX (const MAX::container& MAX)
  {
    this->_xsd_MAX_ = MAX;
  }

  void VALUES::
  MAX (::std::auto_ptr< MAX::type > MAX)
  {
    this->_xsd_MAX_.set (MAX);
  }

  const VALUES::OPTION::container& VALUES::
  OPTION () const
  {
    return this->_xsd_OPTION_;
  }

  VALUES::OPTION::container& VALUES::
  OPTION ()
  {
    return this->_xsd_OPTION_;
  }

  void VALUES::
  OPTION (const OPTION::container& OPTION)
  {
    this->_xsd_OPTION_ = OPTION;
  }

  const VALUES::ID::container& VALUES::
  ID () const
  {
    return this->_xsd_ID_;
  }

  VALUES::ID::container& VALUES::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void VALUES::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void VALUES::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void VALUES::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const VALUES::type::type_& VALUES::type::
  default_value ()
  {
    return default_value_;
  }

  const VALUES::type::type_& VALUES::
  type () const
  {
    return this->_xsd_type_.get ();
  }

  VALUES::type::type_& VALUES::
  type ()
  {
    return this->_xsd_type_.get ();
  }

  void VALUES::
  type (const type::type_& type)
  {
    this->_xsd_type_.set (type);
  }

  void VALUES::
  type (::std::auto_ptr< type::type_ > type)
  {
    this->_xsd_type_.set (type);
  }

  const VALUES::null::container& VALUES::
  null () const
  {
    return this->_xsd_null_;
  }

  VALUES::null::container& VALUES::
  null ()
  {
    return this->_xsd_null_;
  }

  void VALUES::
  null (const null::type& null)
  {
    this->_xsd_null_.set (null);
  }

  void VALUES::
  null (const null::container& null)
  {
    this->_xsd_null_ = null;
  }

  void VALUES::
  null (::std::auto_ptr< null::type > null)
  {
    this->_xsd_null_.set (null);
  }

  const VALUES::ref::container& VALUES::
  ref () const
  {
    return this->_xsd_ref_;
  }

  VALUES::ref::container& VALUES::
  ref ()
  {
    return this->_xsd_ref_;
  }

  void VALUES::
  ref (const ref::type& ref)
  {
    this->_xsd_ref_.set (ref);
  }

  void VALUES::
  ref (const ref::container& ref)
  {
    this->_xsd_ref_ = ref;
  }

  void VALUES::
  ref (::std::auto_ptr< ref::type > ref)
  {
    this->_xsd_ref_.set (ref);
  }


  // MIN
  // 

  const MIN::value::type& MIN::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  MIN::value::type& MIN::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void MIN::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void MIN::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const MIN::inclusive::type& MIN::inclusive::
  default_value ()
  {
    return default_value_;
  }

  const MIN::inclusive::type& MIN::
  inclusive () const
  {
    return this->_xsd_inclusive_.get ();
  }

  MIN::inclusive::type& MIN::
  inclusive ()
  {
    return this->_xsd_inclusive_.get ();
  }

  void MIN::
  inclusive (const inclusive::type& inclusive)
  {
    this->_xsd_inclusive_.set (inclusive);
  }

  void MIN::
  inclusive (::std::auto_ptr< inclusive::type > inclusive)
  {
    this->_xsd_inclusive_.set (inclusive);
  }


  // MAX
  // 

  const MAX::value::type& MAX::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  MAX::value::type& MAX::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void MAX::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void MAX::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const MAX::inclusive::type& MAX::inclusive::
  default_value ()
  {
    return default_value_;
  }

  const MAX::inclusive::type& MAX::
  inclusive () const
  {
    return this->_xsd_inclusive_.get ();
  }

  MAX::inclusive::type& MAX::
  inclusive ()
  {
    return this->_xsd_inclusive_.get ();
  }

  void MAX::
  inclusive (const inclusive::type& inclusive)
  {
    this->_xsd_inclusive_.set (inclusive);
  }

  void MAX::
  inclusive (::std::auto_ptr< inclusive::type > inclusive)
  {
    this->_xsd_inclusive_.set (inclusive);
  }


  // OPTION
  // 

  const OPTION::OPTION1::container& OPTION::
  OPTION1 () const
  {
    return this->_xsd_OPTION1_;
  }

  OPTION::OPTION1::container& OPTION::
  OPTION1 ()
  {
    return this->_xsd_OPTION1_;
  }

  void OPTION::
  OPTION1 (const OPTION1::container& OPTION1)
  {
    this->_xsd_OPTION1_ = OPTION1;
  }

  const OPTION::name::container& OPTION::
  name () const
  {
    return this->_xsd_name_;
  }

  OPTION::name::container& OPTION::
  name ()
  {
    return this->_xsd_name_;
  }

  void OPTION::
  name (const name::type& name)
  {
    this->_xsd_name_.set (name);
  }

  void OPTION::
  name (const name::container& name)
  {
    this->_xsd_name_ = name;
  }

  void OPTION::
  name (::std::auto_ptr< name::type > name)
  {
    this->_xsd_name_.set (name);
  }

  const OPTION::value::type& OPTION::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  OPTION::value::type& OPTION::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void OPTION::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void OPTION::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }


  // LINK
  // 

  const LINK::ID::container& LINK::
  ID () const
  {
    return this->_xsd_ID_;
  }

  LINK::ID::container& LINK::
  ID ()
  {
    return this->_xsd_ID_;
  }

  void LINK::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void LINK::
  ID (const ID::container& ID)
  {
    this->_xsd_ID_ = ID;
  }

  void LINK::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const LINK::content_role::container& LINK::
  content_role () const
  {
    return this->_xsd_content_role_;
  }

  LINK::content_role::container& LINK::
  content_role ()
  {
    return this->_xsd_content_role_;
  }

  void LINK::
  content_role (const content_role::type& content_role)
  {
    this->_xsd_content_role_.set (content_role);
  }

  void LINK::
  content_role (const content_role::container& content_role)
  {
    this->_xsd_content_role_ = content_role;
  }

  void LINK::
  content_role (::std::auto_ptr< content_role::type > content_role)
  {
    this->_xsd_content_role_.set (content_role);
  }

  const LINK::content_type::container& LINK::
  content_type () const
  {
    return this->_xsd_content_type_;
  }

  LINK::content_type::container& LINK::
  content_type ()
  {
    return this->_xsd_content_type_;
  }

  void LINK::
  content_type (const content_type::type& content_type)
  {
    this->_xsd_content_type_.set (content_type);
  }

  void LINK::
  content_type (const content_type::container& content_type)
  {
    this->_xsd_content_type_ = content_type;
  }

  void LINK::
  content_type (::std::auto_ptr< content_type::type > content_type)
  {
    this->_xsd_content_type_.set (content_type);
  }

  const LINK::title::container& LINK::
  title () const
  {
    return this->_xsd_title_;
  }

  LINK::title::container& LINK::
  title ()
  {
    return this->_xsd_title_;
  }

  void LINK::
  title (const title::type& title)
  {
    this->_xsd_title_.set (title);
  }

  void LINK::
  title (const title::container& title)
  {
    this->_xsd_title_ = title;
  }

  void LINK::
  title (::std::auto_ptr< title::type > title)
  {
    this->_xsd_title_.set (title);
  }

  const LINK::value::container& LINK::
  value () const
  {
    return this->_xsd_value_;
  }

  LINK::value::container& LINK::
  value ()
  {
    return this->_xsd_value_;
  }

  void LINK::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void LINK::
  value (const value::container& value)
  {
    this->_xsd_value_ = value;
  }

  void LINK::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const LINK::href::container& LINK::
  href () const
  {
    return this->_xsd_href_;
  }

  LINK::href::container& LINK::
  href ()
  {
    return this->_xsd_href_;
  }

  void LINK::
  href (const href::type& href)
  {
    this->_xsd_href_.set (href);
  }

  void LINK::
  href (const href::container& href)
  {
    this->_xsd_href_ = href;
  }

  void LINK::
  href (::std::auto_ptr< href::type > href)
  {
    this->_xsd_href_.set (href);
  }

  const LINK::gref::container& LINK::
  gref () const
  {
    return this->_xsd_gref_;
  }

  LINK::gref::container& LINK::
  gref ()
  {
    return this->_xsd_gref_;
  }

  void LINK::
  gref (const gref::type& gref)
  {
    this->_xsd_gref_.set (gref);
  }

  void LINK::
  gref (const gref::container& gref)
  {
    this->_xsd_gref_ = gref;
  }

  void LINK::
  gref (::std::auto_ptr< gref::type > gref)
  {
    this->_xsd_gref_.set (gref);
  }

  const LINK::action::container& LINK::
  action () const
  {
    return this->_xsd_action_;
  }

  LINK::action::container& LINK::
  action ()
  {
    return this->_xsd_action_;
  }

  void LINK::
  action (const action::type& action)
  {
    this->_xsd_action_.set (action);
  }

  void LINK::
  action (const action::container& action)
  {
    this->_xsd_action_ = action;
  }

  void LINK::
  action (::std::auto_ptr< action::type > action)
  {
    this->_xsd_action_.set (action);
  }


  // DATA
  // 

  const DATA::TABLEDATA::container& DATA::
  TABLEDATA () const
  {
    return this->_xsd_TABLEDATA_;
  }

  DATA::TABLEDATA::container& DATA::
  TABLEDATA ()
  {
    return this->_xsd_TABLEDATA_;
  }

  void DATA::
  TABLEDATA (const TABLEDATA::type& TABLEDATA)
  {
    this->_xsd_TABLEDATA_.set (TABLEDATA);
  }

  void DATA::
  TABLEDATA (const TABLEDATA::container& TABLEDATA)
  {
    this->_xsd_TABLEDATA_ = TABLEDATA;
  }

  void DATA::
  TABLEDATA (::std::auto_ptr< TABLEDATA::type > TABLEDATA)
  {
    this->_xsd_TABLEDATA_.set (TABLEDATA);
  }

  const DATA::BINARY::container& DATA::
  BINARY () const
  {
    return this->_xsd_BINARY_;
  }

  DATA::BINARY::container& DATA::
  BINARY ()
  {
    return this->_xsd_BINARY_;
  }

  void DATA::
  BINARY (const BINARY::type& BINARY)
  {
    this->_xsd_BINARY_.set (BINARY);
  }

  void DATA::
  BINARY (const BINARY::container& BINARY)
  {
    this->_xsd_BINARY_ = BINARY;
  }

  void DATA::
  BINARY (::std::auto_ptr< BINARY::type > BINARY)
  {
    this->_xsd_BINARY_.set (BINARY);
  }

  const DATA::FITS::container& DATA::
  FITS () const
  {
    return this->_xsd_FITS_;
  }

  DATA::FITS::container& DATA::
  FITS ()
  {
    return this->_xsd_FITS_;
  }

  void DATA::
  FITS (const FITS::type& FITS)
  {
    this->_xsd_FITS_.set (FITS);
  }

  void DATA::
  FITS (const FITS::container& FITS)
  {
    this->_xsd_FITS_ = FITS;
  }

  void DATA::
  FITS (::std::auto_ptr< FITS::type > FITS)
  {
    this->_xsd_FITS_.set (FITS);
  }


  // TABLEDATA
  // 

  const TABLEDATA::TR::container& TABLEDATA::
  TR () const
  {
    return this->_xsd_TR_;
  }

  TABLEDATA::TR::container& TABLEDATA::
  TR ()
  {
    return this->_xsd_TR_;
  }

  void TABLEDATA::
  TR (const TR::container& TR)
  {
    this->_xsd_TR_ = TR;
  }


  // TD
  // 

  const TD::encoding::container& TD::
  encoding () const
  {
    return this->_xsd_encoding_;
  }

  TD::encoding::container& TD::
  encoding ()
  {
    return this->_xsd_encoding_;
  }

  void TD::
  encoding (const encoding::type& encoding)
  {
    this->_xsd_encoding_.set (encoding);
  }

  void TD::
  encoding (const encoding::container& encoding)
  {
    this->_xsd_encoding_ = encoding;
  }

  void TD::
  encoding (::std::auto_ptr< encoding::type > encoding)
  {
    this->_xsd_encoding_.set (encoding);
  }


  // TR
  // 

  const TR::TD::container& TR::
  TD () const
  {
    return this->_xsd_TD_;
  }

  TR::TD::container& TR::
  TD ()
  {
    return this->_xsd_TD_;
  }

  void TR::
  TD (const TD::container& TD)
  {
    this->_xsd_TD_ = TD;
  }


  // FITS
  // 

  const FITS::STREAM::type& FITS::
  STREAM () const
  {
    return this->_xsd_STREAM_.get ();
  }

  FITS::STREAM::type& FITS::
  STREAM ()
  {
    return this->_xsd_STREAM_.get ();
  }

  void FITS::
  STREAM (const STREAM::type& STREAM)
  {
    this->_xsd_STREAM_.set (STREAM);
  }

  void FITS::
  STREAM (::std::auto_ptr< STREAM::type > STREAM)
  {
    this->_xsd_STREAM_.set (STREAM);
  }

  const FITS::extnum::container& FITS::
  extnum () const
  {
    return this->_xsd_extnum_;
  }

  FITS::extnum::container& FITS::
  extnum ()
  {
    return this->_xsd_extnum_;
  }

  void FITS::
  extnum (const extnum::type& extnum)
  {
    this->_xsd_extnum_.set (extnum);
  }

  void FITS::
  extnum (const extnum::container& extnum)
  {
    this->_xsd_extnum_ = extnum;
  }


  // BINARY
  // 

  const BINARY::STREAM::type& BINARY::
  STREAM () const
  {
    return this->_xsd_STREAM_.get ();
  }

  BINARY::STREAM::type& BINARY::
  STREAM ()
  {
    return this->_xsd_STREAM_.get ();
  }

  void BINARY::
  STREAM (const STREAM::type& STREAM)
  {
    this->_xsd_STREAM_.set (STREAM);
  }

  void BINARY::
  STREAM (::std::auto_ptr< STREAM::type > STREAM)
  {
    this->_xsd_STREAM_.set (STREAM);
  }


  // STREAM
  // 

  const STREAM::type::type_& STREAM::type::
  default_value ()
  {
    return default_value_;
  }

  const STREAM::type::type_& STREAM::
  type () const
  {
    return this->_xsd_type_.get ();
  }

  STREAM::type::type_& STREAM::
  type ()
  {
    return this->_xsd_type_.get ();
  }

  void STREAM::
  type (const type::type_& type)
  {
    this->_xsd_type_.set (type);
  }

  void STREAM::
  type (::std::auto_ptr< type::type_ > type)
  {
    this->_xsd_type_.set (type);
  }

  const STREAM::href::container& STREAM::
  href () const
  {
    return this->_xsd_href_;
  }

  STREAM::href::container& STREAM::
  href ()
  {
    return this->_xsd_href_;
  }

  void STREAM::
  href (const href::type& href)
  {
    this->_xsd_href_.set (href);
  }

  void STREAM::
  href (const href::container& href)
  {
    this->_xsd_href_ = href;
  }

  void STREAM::
  href (::std::auto_ptr< href::type > href)
  {
    this->_xsd_href_.set (href);
  }

  const STREAM::actuate::type& STREAM::actuate::
  default_value ()
  {
    return default_value_;
  }

  const STREAM::actuate::type& STREAM::
  actuate () const
  {
    return this->_xsd_actuate_.get ();
  }

  STREAM::actuate::type& STREAM::
  actuate ()
  {
    return this->_xsd_actuate_.get ();
  }

  void STREAM::
  actuate (const actuate::type& actuate)
  {
    this->_xsd_actuate_.set (actuate);
  }

  void STREAM::
  actuate (::std::auto_ptr< actuate::type > actuate)
  {
    this->_xsd_actuate_.set (actuate);
  }

  const STREAM::encoding::type& STREAM::encoding::
  default_value ()
  {
    return default_value_;
  }

  const STREAM::encoding::type& STREAM::
  encoding () const
  {
    return this->_xsd_encoding_.get ();
  }

  STREAM::encoding::type& STREAM::
  encoding ()
  {
    return this->_xsd_encoding_.get ();
  }

  void STREAM::
  encoding (const encoding::type& encoding)
  {
    this->_xsd_encoding_.set (encoding);
  }

  void STREAM::
  encoding (::std::auto_ptr< encoding::type > encoding)
  {
    this->_xsd_encoding_.set (encoding);
  }

  const STREAM::expires::container& STREAM::
  expires () const
  {
    return this->_xsd_expires_;
  }

  STREAM::expires::container& STREAM::
  expires ()
  {
    return this->_xsd_expires_;
  }

  void STREAM::
  expires (const expires::type& expires)
  {
    this->_xsd_expires_.set (expires);
  }

  void STREAM::
  expires (const expires::container& expires)
  {
    this->_xsd_expires_ = expires;
  }

  void STREAM::
  expires (::std::auto_ptr< expires::type > expires)
  {
    this->_xsd_expires_.set (expires);
  }

  const STREAM::rights::container& STREAM::
  rights () const
  {
    return this->_xsd_rights_;
  }

  STREAM::rights::container& STREAM::
  rights ()
  {
    return this->_xsd_rights_;
  }

  void STREAM::
  rights (const rights::type& rights)
  {
    this->_xsd_rights_.set (rights);
  }

  void STREAM::
  rights (const rights::container& rights)
  {
    this->_xsd_rights_ = rights;
  }

  void STREAM::
  rights (::std::auto_ptr< rights::type > rights)
  {
    this->_xsd_rights_.set (rights);
  }


  // COOSYS
  // 

  const COOSYS::ID::type& COOSYS::
  ID () const
  {
    return this->_xsd_ID_.get ();
  }

  COOSYS::ID::type& COOSYS::
  ID ()
  {
    return this->_xsd_ID_.get ();
  }

  void COOSYS::
  ID (const ID::type& ID)
  {
    this->_xsd_ID_.set (ID);
  }

  void COOSYS::
  ID (::std::auto_ptr< ID::type > ID)
  {
    this->_xsd_ID_.set (ID);
  }

  const COOSYS::equinox::container& COOSYS::
  equinox () const
  {
    return this->_xsd_equinox_;
  }

  COOSYS::equinox::container& COOSYS::
  equinox ()
  {
    return this->_xsd_equinox_;
  }

  void COOSYS::
  equinox (const equinox::type& equinox)
  {
    this->_xsd_equinox_.set (equinox);
  }

  void COOSYS::
  equinox (const equinox::container& equinox)
  {
    this->_xsd_equinox_ = equinox;
  }

  void COOSYS::
  equinox (::std::auto_ptr< equinox::type > equinox)
  {
    this->_xsd_equinox_.set (equinox);
  }

  const COOSYS::epoch::container& COOSYS::
  epoch () const
  {
    return this->_xsd_epoch_;
  }

  COOSYS::epoch::container& COOSYS::
  epoch ()
  {
    return this->_xsd_epoch_;
  }

  void COOSYS::
  epoch (const epoch::type& epoch)
  {
    this->_xsd_epoch_.set (epoch);
  }

  void COOSYS::
  epoch (const epoch::container& epoch)
  {
    this->_xsd_epoch_ = epoch;
  }

  void COOSYS::
  epoch (::std::auto_ptr< epoch::type > epoch)
  {
    this->_xsd_epoch_.set (epoch);
  }

  const COOSYS::system::type& COOSYS::system::
  default_value ()
  {
    return default_value_;
  }

  const COOSYS::system::type& COOSYS::
  system () const
  {
    return this->_xsd_system_.get ();
  }

  COOSYS::system::type& COOSYS::
  system ()
  {
    return this->_xsd_system_.get ();
  }

  void COOSYS::
  system (const system::type& system)
  {
    this->_xsd_system_.set (system);
  }

  void COOSYS::
  system (::std::auto_ptr< system::type > system)
  {
    this->_xsd_system_.set (system);
  }


  // version
  // 

  version::
  version (_xsd_version v)
  : ::xml_schema::nmtoken (_xsd_version_literals_[v])
  {
  }

  version::
  version (const ::xml_schema::nmtoken& _xsd_version)
  : ::xml_schema::nmtoken (_xsd_version)
  {
  }

  version::
  version (const version& v,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  version& version::
  operator= (_xsd_version v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_version_literals_[v]);

    return *this;
  }


  // type
  // 

  type::
  type (_xsd_type v)
  : ::xml_schema::nmtoken (_xsd_type_literals_[v])
  {
  }

  type::
  type (const ::xml_schema::nmtoken& _xsd_type)
  : ::xml_schema::nmtoken (_xsd_type)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type& type::
  operator= (_xsd_type v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type_literals_[v]);

    return *this;
  }


  // type1
  // 

  type1::
  type1 (_xsd_type1 v)
  : ::xml_schema::nmtoken (_xsd_type1_literals_[v])
  {
  }

  type1::
  type1 (const ::xml_schema::nmtoken& _xsd_type1)
  : ::xml_schema::nmtoken (_xsd_type1)
  {
  }

  type1::
  type1 (const type1& v,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type1& type1::
  operator= (_xsd_type1 v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type1_literals_[v]);

    return *this;
  }


  // type2
  // 

  type2::
  type2 (_xsd_type2 v)
  : ::xml_schema::nmtoken (_xsd_type2_literals_[v])
  {
  }

  type2::
  type2 (const ::xml_schema::nmtoken& _xsd_type2)
  : ::xml_schema::nmtoken (_xsd_type2)
  {
  }

  type2::
  type2 (const type2& v,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type2& type2::
  operator= (_xsd_type2 v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type2_literals_[v]);

    return *this;
  }


  // content_role
  // 

  content_role::
  content_role (_xsd_content_role v)
  : ::xml_schema::nmtoken (_xsd_content_role_literals_[v])
  {
  }

  content_role::
  content_role (const ::xml_schema::nmtoken& _xsd_content_role)
  : ::xml_schema::nmtoken (_xsd_content_role)
  {
  }

  content_role::
  content_role (const content_role& v,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  content_role& content_role::
  operator= (_xsd_content_role v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_content_role_literals_[v]);

    return *this;
  }


  // type3
  // 

  type3::
  type3 (_xsd_type3 v)
  : ::xml_schema::nmtoken (_xsd_type3_literals_[v])
  {
  }

  type3::
  type3 (const ::xml_schema::nmtoken& _xsd_type3)
  : ::xml_schema::nmtoken (_xsd_type3)
  {
  }

  type3::
  type3 (const type3& v,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  type3& type3::
  operator= (_xsd_type3 v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_type3_literals_[v]);

    return *this;
  }


  // actuate
  // 

  actuate::
  actuate (_xsd_actuate v)
  : ::xml_schema::nmtoken (_xsd_actuate_literals_[v])
  {
  }

  actuate::
  actuate (const ::xml_schema::nmtoken& _xsd_actuate)
  : ::xml_schema::nmtoken (_xsd_actuate)
  {
  }

  actuate::
  actuate (const actuate& v,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  actuate& actuate::
  operator= (_xsd_actuate v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_actuate_literals_[v]);

    return *this;
  }


  // system
  // 

  system::
  system (_xsd_system v)
  : ::xml_schema::nmtoken (_xsd_system_literals_[v])
  {
  }

  system::
  system (const ::xml_schema::nmtoken& _xsd_system)
  : ::xml_schema::nmtoken (_xsd_system)
  {
  }

  system::
  system (const system& v,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::nmtoken (v, f, c)
  {
  }

  system& system::
  operator= (_xsd_system v)
  {
    static_cast< ::xml_schema::nmtoken& > (*this) = 
    ::xml_schema::nmtoken (_xsd_system_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

namespace votable
{
  // anyTEXT
  //

  anyTEXT::
  anyTEXT ()
  : ::xml_schema::type ()
  {
  }

  anyTEXT::
  anyTEXT (const anyTEXT& _xsd_anyTEXT,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_anyTEXT, f, c)
  {
  }

  anyTEXT::
  anyTEXT (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  anyTEXT::
  anyTEXT (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  anyTEXT::
  anyTEXT (const ::std::basic_string< char >& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  anyTEXT* anyTEXT::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new anyTEXT (*this, f, c);
  }

  // astroYear
  //

  astroYear::
  astroYear (const _xsd_astroYear::base_& _xsd_astroYear)
  : ::xml_schema::token (_xsd_astroYear)
  {
  }

  astroYear::
  astroYear (const astroYear& _xsd_astroYear,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::token (_xsd_astroYear, f, c)
  {
  }

  astroYear::
  astroYear (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  astroYear::
  astroYear (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  astroYear::
  astroYear (const ::std::basic_string< char >& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  astroYear* astroYear::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new astroYear (*this, f, c);
  }

  // ucdType
  //

  ucdType::
  ucdType (const _xsd_ucdType::base_& _xsd_ucdType)
  : ::xml_schema::token (_xsd_ucdType)
  {
  }

  ucdType::
  ucdType (const ucdType& _xsd_ucdType,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::token (_xsd_ucdType, f, c)
  {
  }

  ucdType::
  ucdType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  ucdType::
  ucdType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  ucdType::
  ucdType (const ::std::basic_string< char >& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  ucdType* ucdType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ucdType (*this, f, c);
  }

  // arrayDEF
  //

  arrayDEF::
  arrayDEF (const _xsd_arrayDEF::base_& _xsd_arrayDEF)
  : ::xml_schema::token (_xsd_arrayDEF)
  {
  }

  arrayDEF::
  arrayDEF (const arrayDEF& _xsd_arrayDEF,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (_xsd_arrayDEF, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  arrayDEF::
  arrayDEF (const ::std::basic_string< char >& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  arrayDEF* arrayDEF::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new arrayDEF (*this, f, c);
  }

  // encodingType
  //

  encodingType::
  encodingType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType::
  encodingType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType::
  encodingType (const ::std::basic_string< char >& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_encodingType_convert ();
  }

  encodingType* encodingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new encodingType (*this, f, c);
  }

  encodingType::_xsd_encodingType encodingType::
  _xsd_encodingType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_encodingType_literals_);
    const _xsd_encodingType* i (::std::lower_bound (
                                  _xsd_encodingType_indexes_,
                                  _xsd_encodingType_indexes_ + 4,
                                  *this,
                                  c));

    if (i == _xsd_encodingType_indexes_ + 4 || _xsd_encodingType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const encodingType::
  _xsd_encodingType_literals_[4] =
  {
    "gzip",
    "base64",
    "dynamic",
    "none"
  };

  const encodingType::_xsd_encodingType encodingType::
  _xsd_encodingType_indexes_[4] =
  {
    ::votable::encodingType::base64,
    ::votable::encodingType::dynamic,
    ::votable::encodingType::gzip,
    ::votable::encodingType::none
  };

  // dataType
  //

  dataType::
  dataType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType::
  dataType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType::
  dataType (const ::std::basic_string< char >& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_dataType_convert ();
  }

  dataType* dataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new dataType (*this, f, c);
  }

  dataType::_xsd_dataType dataType::
  _xsd_dataType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dataType_literals_);
    const _xsd_dataType* i (::std::lower_bound (
                              _xsd_dataType_indexes_,
                              _xsd_dataType_indexes_ + 12,
                              *this,
                              c));

    if (i == _xsd_dataType_indexes_ + 12 || _xsd_dataType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const dataType::
  _xsd_dataType_literals_[12] =
  {
    "boolean",
    "bit",
    "unsignedByte",
    "short",
    "int",
    "long",
    "char",
    "unicodeChar",
    "float",
    "double",
    "floatComplex",
    "doubleComplex"
  };

  const dataType::_xsd_dataType dataType::
  _xsd_dataType_indexes_[12] =
  {
    ::votable::dataType::bit,
    ::votable::dataType::boolean,
    ::votable::dataType::char_,
    ::votable::dataType::double_,
    ::votable::dataType::doubleComplex,
    ::votable::dataType::float_,
    ::votable::dataType::floatComplex,
    ::votable::dataType::int_,
    ::votable::dataType::long_,
    ::votable::dataType::short_,
    ::votable::dataType::unicodeChar,
    ::votable::dataType::unsignedByte
  };

  // precType
  //

  precType::
  precType (const _xsd_precType::base_& _xsd_precType)
  : ::xml_schema::token (_xsd_precType)
  {
  }

  precType::
  precType (const precType& _xsd_precType,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (_xsd_precType, f, c)
  {
  }

  precType::
  precType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  precType::
  precType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  precType::
  precType (const ::std::basic_string< char >& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  precType* precType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new precType (*this, f, c);
  }

  // yesno
  //

  yesno::
  yesno (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno::
  yesno (const ::std::basic_string< char >& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_yesno_convert ();
  }

  yesno* yesno::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new yesno (*this, f, c);
  }

  yesno::_xsd_yesno yesno::
  _xsd_yesno_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yesno_literals_);
    const _xsd_yesno* i (::std::lower_bound (
                           _xsd_yesno_indexes_,
                           _xsd_yesno_indexes_ + 2,
                           *this,
                           c));

    if (i == _xsd_yesno_indexes_ + 2 || _xsd_yesno_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yesno::
  _xsd_yesno_literals_[2] =
  {
    "yes",
    "no"
  };

  const yesno::_xsd_yesno yesno::
  _xsd_yesno_indexes_[2] =
  {
    ::votable::yesno::no,
    ::votable::yesno::yes
  };

  // VOTABLE
  //

  VOTABLE::
  VOTABLE ()
  : ::xml_schema::type (),
  _xsd_DESCRIPTION_ (::xml_schema::flags (), this),
  _xsd_DEFINITIONS_ (::xml_schema::flags (), this),
  _xsd_COOSYS_ (::xml_schema::flags (), this),
  _xsd_PARAM_ (::xml_schema::flags (), this),
  _xsd_INFO_ (::xml_schema::flags (), this),
  _xsd_RESOURCE_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_version_ (::xml_schema::flags (), this)
  {
  }

  VOTABLE::
  VOTABLE (const VOTABLE& _xsd_VOTABLE,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_VOTABLE, f, c),
  _xsd_DESCRIPTION_ (_xsd_VOTABLE._xsd_DESCRIPTION_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_DEFINITIONS_ (_xsd_VOTABLE._xsd_DEFINITIONS_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_COOSYS_ (_xsd_VOTABLE._xsd_COOSYS_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_PARAM_ (_xsd_VOTABLE._xsd_PARAM_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_INFO_ (_xsd_VOTABLE._xsd_INFO_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_RESOURCE_ (_xsd_VOTABLE._xsd_RESOURCE_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_ID_ (_xsd_VOTABLE._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_version_ (_xsd_VOTABLE._xsd_version_,
                 f | ::xml_schema::flags::not_root,
                 this)
  {
  }

  VOTABLE::
  VOTABLE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_DESCRIPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_DEFINITIONS_ (f | ::xml_schema::flags::not_root, this),
  _xsd_COOSYS_ (f | ::xml_schema::flags::not_root, this),
  _xsd_PARAM_ (f | ::xml_schema::flags::not_root, this),
  _xsd_INFO_ (f | ::xml_schema::flags::not_root, this),
  _xsd_RESOURCE_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_version_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void VOTABLE::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // DESCRIPTION
      //
      {
        if (e.name () == "DESCRIPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DESCRIPTION::type > r (
            DESCRIPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DESCRIPTION ())
            continue;
          this->DESCRIPTION (r);
          continue;
        }
      }

      // DEFINITIONS
      //
      {
        if (e.name () == "DEFINITIONS" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DEFINITIONS::type > r (
            DEFINITIONS::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DEFINITIONS ())
            continue;
          this->DEFINITIONS (r);
          continue;
        }
      }

      // COOSYS
      //
      {
        if (e.name () == "COOSYS" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< COOSYS::type > r (
            COOSYS::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->COOSYS ().push_back (r);
          continue;
        }
      }

      // PARAM
      //
      {
        if (e.name () == "PARAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< PARAM::type > r (
            PARAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->PARAM ().push_back (r);
          continue;
        }
      }

      // INFO
      //
      {
        if (e.name () == "INFO" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< INFO::type > r (
            INFO::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->INFO ().push_back (r);
          continue;
        }
      }

      // RESOURCE
      //
      {
        if (e.name () == "RESOURCE" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< RESOURCE::type > r (
            RESOURCE::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->RESOURCE ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "version" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< version::type > r (
          version::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->version (r);
        continue;
      }
    }
  }

  VOTABLE* VOTABLE::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new VOTABLE (*this, f, c);
  }

  // RESOURCE
  //

  // RESOURCE::type
  // 

  const RESOURCE::type::type_ RESOURCE::type::default_value_ (
    ::std::basic_string< char > ("results"), 0, 0, 0);

  RESOURCE::
  RESOURCE ()
  : ::xml_schema::type (),
  _xsd_DESCRIPTION_ (::xml_schema::flags (), this),
  _xsd_INFO_ (::xml_schema::flags (), this),
  _xsd_COOSYS_ (::xml_schema::flags (), this),
  _xsd_PARAM_ (::xml_schema::flags (), this),
  _xsd_LINK_ (::xml_schema::flags (), this),
  _xsd_TABLE_ (::xml_schema::flags (), this),
  _xsd_RESOURCE1_ (::xml_schema::flags (), this),
  _xsd_name_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_utype_ (::xml_schema::flags (), this),
  _xsd_type_ (type::default_value (),
              ::xml_schema::flags (),
              this)
  {
  }

  RESOURCE::
  RESOURCE (const RESOURCE& _xsd_RESOURCE,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_RESOURCE, f, c),
  _xsd_DESCRIPTION_ (_xsd_RESOURCE._xsd_DESCRIPTION_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_INFO_ (_xsd_RESOURCE._xsd_INFO_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_COOSYS_ (_xsd_RESOURCE._xsd_COOSYS_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_PARAM_ (_xsd_RESOURCE._xsd_PARAM_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_LINK_ (_xsd_RESOURCE._xsd_LINK_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_TABLE_ (_xsd_RESOURCE._xsd_TABLE_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_RESOURCE1_ (_xsd_RESOURCE._xsd_RESOURCE1_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_name_ (_xsd_RESOURCE._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ID_ (_xsd_RESOURCE._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_utype_ (_xsd_RESOURCE._xsd_utype_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_type_ (_xsd_RESOURCE._xsd_type_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  RESOURCE::
  RESOURCE (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_DESCRIPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_INFO_ (f | ::xml_schema::flags::not_root, this),
  _xsd_COOSYS_ (f | ::xml_schema::flags::not_root, this),
  _xsd_PARAM_ (f | ::xml_schema::flags::not_root, this),
  _xsd_LINK_ (f | ::xml_schema::flags::not_root, this),
  _xsd_TABLE_ (f | ::xml_schema::flags::not_root, this),
  _xsd_RESOURCE1_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_utype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_type_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void RESOURCE::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // DESCRIPTION
      //
      {
        if (e.name () == "DESCRIPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DESCRIPTION::type > r (
            DESCRIPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DESCRIPTION ())
            continue;
          this->DESCRIPTION (r);
          continue;
        }
      }

      // INFO
      //
      {
        if (e.name () == "INFO" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< INFO::type > r (
            INFO::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->INFO ().push_back (r);
          continue;
        }
      }

      // COOSYS
      //
      {
        if (e.name () == "COOSYS" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< COOSYS::type > r (
            COOSYS::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->COOSYS ().push_back (r);
          continue;
        }
      }

      // PARAM
      //
      {
        if (e.name () == "PARAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< PARAM::type > r (
            PARAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->PARAM ().push_back (r);
          continue;
        }
      }

      // LINK
      //
      {
        if (e.name () == "LINK" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< LINK::type > r (
            LINK::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->LINK ().push_back (r);
          continue;
        }
      }

      // TABLE
      //
      {
        if (e.name () == "TABLE" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< TABLE::type > r (
            TABLE::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->TABLE ().push_back (r);
          continue;
        }
      }

      // RESOURCE1
      //
      {
        if (e.name () == "RESOURCE" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< RESOURCE1::type > r (
            RESOURCE1::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->RESOURCE1 ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "utype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype::type > r (
          utype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->utype (r);
        continue;
      }

      if (a.name () == "type" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< type::type_ > r (
          type::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->type (r);
        continue;
      }
    }

    if (!_xsd_type_.present ())
    {
      this->type (
        type::traits::create (
          ::std::basic_string< char > ("results"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }
  }

  RESOURCE* RESOURCE::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new RESOURCE (*this, f, c);
  }

  // DEFINITIONS
  //

  DEFINITIONS::
  DEFINITIONS ()
  : ::xml_schema::type (),
  _xsd_COOSYS_ (::xml_schema::flags (), this),
  _xsd_PARAM_ (::xml_schema::flags (), this)
  {
  }

  DEFINITIONS::
  DEFINITIONS (const DEFINITIONS& _xsd_DEFINITIONS,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_DEFINITIONS, f, c),
  _xsd_COOSYS_ (_xsd_DEFINITIONS._xsd_COOSYS_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_PARAM_ (_xsd_DEFINITIONS._xsd_PARAM_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  DEFINITIONS::
  DEFINITIONS (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_COOSYS_ (f | ::xml_schema::flags::not_root, this),
  _xsd_PARAM_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void DEFINITIONS::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // COOSYS
      //
      {
        if (e.name () == "COOSYS" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< COOSYS::type > r (
            COOSYS::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->COOSYS ().push_back (r);
          continue;
        }
      }

      // PARAM
      //
      {
        if (e.name () == "PARAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< PARAM::type > r (
            PARAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->PARAM ().push_back (r);
          continue;
        }
      }
    }
  }

  DEFINITIONS* DEFINITIONS::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new DEFINITIONS (*this, f, c);
  }

  // INFO
  //

  INFO::
  INFO (const _xsd_INFO::base_& _xsd_INFO,
        const name::type& _xsd_name,
        const value::type& _xsd_value)
  : ::xml_schema::string (_xsd_INFO),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_name_ (_xsd_name,
              ::xml_schema::flags (),
              this),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this)
  {
  }

  INFO::
  INFO (const INFO& _xsd_INFO,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::string (_xsd_INFO, f, c),
  _xsd_ID_ (_xsd_INFO._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_name_ (_xsd_INFO._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_value_ (_xsd_INFO._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  INFO::
  INFO (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::string (e, f, c),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void INFO::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "value" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< value::type > r (
          value::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->value (r);
        continue;
      }
    }

    if (!_xsd_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  INFO* INFO::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new INFO (*this, f, c);
  }

  // PARAM
  //

  PARAM::
  PARAM (const datatype::type& _xsd_datatype,
         const name::type& _xsd_name,
         const value::type& _xsd_value)
  : ::xml_schema::type (),
  _xsd_DESCRIPTION_ (::xml_schema::flags (), this),
  _xsd_VALUES_ (::xml_schema::flags (), this),
  _xsd_LINK_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_unit_ (::xml_schema::flags (), this),
  _xsd_datatype_ (_xsd_datatype,
                  ::xml_schema::flags (),
                  this),
  _xsd_precision_ (::xml_schema::flags (), this),
  _xsd_width_ (::xml_schema::flags (), this),
  _xsd_ref_ (::xml_schema::flags (), this),
  _xsd_name_ (_xsd_name,
              ::xml_schema::flags (),
              this),
  _xsd_ucd_ (::xml_schema::flags (), this),
  _xsd_utype_ (::xml_schema::flags (), this),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this),
  _xsd_arraysize_ (::xml_schema::flags (), this)
  {
  }

  PARAM::
  PARAM (const PARAM& _xsd_PARAM,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_PARAM, f, c),
  _xsd_DESCRIPTION_ (_xsd_PARAM._xsd_DESCRIPTION_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_VALUES_ (_xsd_PARAM._xsd_VALUES_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_LINK_ (_xsd_PARAM._xsd_LINK_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ID_ (_xsd_PARAM._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_unit_ (_xsd_PARAM._xsd_unit_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_datatype_ (_xsd_PARAM._xsd_datatype_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_precision_ (_xsd_PARAM._xsd_precision_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_width_ (_xsd_PARAM._xsd_width_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_ref_ (_xsd_PARAM._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_name_ (_xsd_PARAM._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ucd_ (_xsd_PARAM._xsd_ucd_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_utype_ (_xsd_PARAM._xsd_utype_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_value_ (_xsd_PARAM._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_arraysize_ (_xsd_PARAM._xsd_arraysize_,
                   f | ::xml_schema::flags::not_root,
                   this)
  {
  }

  PARAM::
  PARAM (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_DESCRIPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_VALUES_ (f | ::xml_schema::flags::not_root, this),
  _xsd_LINK_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_unit_ (f | ::xml_schema::flags::not_root, this),
  _xsd_datatype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_precision_ (f | ::xml_schema::flags::not_root, this),
  _xsd_width_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ucd_ (f | ::xml_schema::flags::not_root, this),
  _xsd_utype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_arraysize_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void PARAM::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // DESCRIPTION
      //
      {
        if (e.name () == "DESCRIPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DESCRIPTION::type > r (
            DESCRIPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DESCRIPTION ())
            continue;
          this->DESCRIPTION (r);
          continue;
        }
      }

      // VALUES
      //
      {
        if (e.name () == "VALUES" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< VALUES::type > r (
            VALUES::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->VALUES ())
            continue;
          this->VALUES (r);
          continue;
        }
      }

      // LINK
      //
      {
        if (e.name () == "LINK" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< LINK::type > r (
            LINK::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->LINK ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "unit" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit::type > r (
          unit::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->unit (r);
        continue;
      }

      if (a.name () == "datatype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype::type > r (
          datatype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->datatype (r);
        continue;
      }

      if (a.name () == "precision" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< precision::type > r (
          precision::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->precision (r);
        continue;
      }

      if (a.name () == "width" && a.namespace_ ().empty ())
      {
        this->width (
          width::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "ucd" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd::type > r (
          ucd::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ucd (r);
        continue;
      }

      if (a.name () == "utype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype::type > r (
          utype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->utype (r);
        continue;
      }

      if (a.name () == "value" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< value::type > r (
          value::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->value (r);
        continue;
      }

      if (a.name () == "arraysize" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< arraysize::type > r (
          arraysize::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->arraysize (r);
        continue;
      }
    }

    if (!_xsd_datatype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "datatype",
        "");
    }

    if (!_xsd_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  PARAM* PARAM::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new PARAM (*this, f, c);
  }

  // TABLE
  //

  TABLE::
  TABLE ()
  : ::xml_schema::type (),
  _xsd_DESCRIPTION_ (::xml_schema::flags (), this),
  _xsd_FIELD_ (::xml_schema::flags (), this),
  _xsd_PARAM_ (::xml_schema::flags (), this),
  _xsd_GROUP_ (::xml_schema::flags (), this),
  _xsd_LINK_ (::xml_schema::flags (), this),
  _xsd_DATA_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_name_ (::xml_schema::flags (), this),
  _xsd_ref_ (::xml_schema::flags (), this),
  _xsd_ucd_ (::xml_schema::flags (), this),
  _xsd_utype_ (::xml_schema::flags (), this),
  _xsd_nrows_ (::xml_schema::flags (), this)
  {
  }

  TABLE::
  TABLE (const TABLE& _xsd_TABLE,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_TABLE, f, c),
  _xsd_DESCRIPTION_ (_xsd_TABLE._xsd_DESCRIPTION_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_FIELD_ (_xsd_TABLE._xsd_FIELD_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_PARAM_ (_xsd_TABLE._xsd_PARAM_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_GROUP_ (_xsd_TABLE._xsd_GROUP_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_LINK_ (_xsd_TABLE._xsd_LINK_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_DATA_ (_xsd_TABLE._xsd_DATA_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ID_ (_xsd_TABLE._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_name_ (_xsd_TABLE._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ref_ (_xsd_TABLE._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_ucd_ (_xsd_TABLE._xsd_ucd_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_utype_ (_xsd_TABLE._xsd_utype_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_nrows_ (_xsd_TABLE._xsd_nrows_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  TABLE::
  TABLE (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_DESCRIPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_FIELD_ (f | ::xml_schema::flags::not_root, this),
  _xsd_PARAM_ (f | ::xml_schema::flags::not_root, this),
  _xsd_GROUP_ (f | ::xml_schema::flags::not_root, this),
  _xsd_LINK_ (f | ::xml_schema::flags::not_root, this),
  _xsd_DATA_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ucd_ (f | ::xml_schema::flags::not_root, this),
  _xsd_utype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_nrows_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void TABLE::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // DESCRIPTION
      //
      {
        if (e.name () == "DESCRIPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DESCRIPTION::type > r (
            DESCRIPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DESCRIPTION ())
            continue;
          this->DESCRIPTION (r);
          continue;
        }
      }

      // FIELD
      //
      {
        if (e.name () == "FIELD" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< FIELD::type > r (
            FIELD::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->FIELD ().push_back (r);
          continue;
        }
      }

      // PARAM
      //
      {
        if (e.name () == "PARAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< PARAM::type > r (
            PARAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->PARAM ().push_back (r);
          continue;
        }
      }

      // GROUP
      //
      {
        if (e.name () == "GROUP" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< GROUP::type > r (
            GROUP::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->GROUP ().push_back (r);
          continue;
        }
      }

      // LINK
      //
      {
        if (e.name () == "LINK" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< LINK::type > r (
            LINK::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->LINK ().push_back (r);
          continue;
        }
      }

      // DATA
      //
      {
        if (e.name () == "DATA" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DATA::type > r (
            DATA::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DATA ())
            continue;
          this->DATA (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }

      if (a.name () == "ucd" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd::type > r (
          ucd::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ucd (r);
        continue;
      }

      if (a.name () == "utype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype::type > r (
          utype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->utype (r);
        continue;
      }

      if (a.name () == "nrows" && a.namespace_ ().empty ())
      {
        this->nrows (
          nrows::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }
  }

  TABLE* TABLE::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new TABLE (*this, f, c);
  }

  // FIELD
  //

  FIELD::
  FIELD (const datatype::type& _xsd_datatype,
         const name::type& _xsd_name)
  : ::xml_schema::type (),
  _xsd_DESCRIPTION_ (::xml_schema::flags (), this),
  _xsd_VALUES_ (::xml_schema::flags (), this),
  _xsd_LINK_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_unit_ (::xml_schema::flags (), this),
  _xsd_datatype_ (_xsd_datatype,
                  ::xml_schema::flags (),
                  this),
  _xsd_precision_ (::xml_schema::flags (), this),
  _xsd_width_ (::xml_schema::flags (), this),
  _xsd_ref_ (::xml_schema::flags (), this),
  _xsd_name_ (_xsd_name,
              ::xml_schema::flags (),
              this),
  _xsd_ucd_ (::xml_schema::flags (), this),
  _xsd_utype_ (::xml_schema::flags (), this),
  _xsd_arraysize_ (::xml_schema::flags (), this),
  _xsd_type_ (::xml_schema::flags (), this)
  {
  }

  FIELD::
  FIELD (const FIELD& _xsd_FIELD,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_FIELD, f, c),
  _xsd_DESCRIPTION_ (_xsd_FIELD._xsd_DESCRIPTION_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_VALUES_ (_xsd_FIELD._xsd_VALUES_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_LINK_ (_xsd_FIELD._xsd_LINK_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ID_ (_xsd_FIELD._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_unit_ (_xsd_FIELD._xsd_unit_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_datatype_ (_xsd_FIELD._xsd_datatype_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_precision_ (_xsd_FIELD._xsd_precision_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_width_ (_xsd_FIELD._xsd_width_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_ref_ (_xsd_FIELD._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_name_ (_xsd_FIELD._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ucd_ (_xsd_FIELD._xsd_ucd_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_utype_ (_xsd_FIELD._xsd_utype_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_arraysize_ (_xsd_FIELD._xsd_arraysize_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_type_ (_xsd_FIELD._xsd_type_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  FIELD::
  FIELD (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_DESCRIPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_VALUES_ (f | ::xml_schema::flags::not_root, this),
  _xsd_LINK_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_unit_ (f | ::xml_schema::flags::not_root, this),
  _xsd_datatype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_precision_ (f | ::xml_schema::flags::not_root, this),
  _xsd_width_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ucd_ (f | ::xml_schema::flags::not_root, this),
  _xsd_utype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_arraysize_ (f | ::xml_schema::flags::not_root, this),
  _xsd_type_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void FIELD::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // DESCRIPTION
      //
      {
        if (e.name () == "DESCRIPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DESCRIPTION::type > r (
            DESCRIPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DESCRIPTION ())
            continue;
          this->DESCRIPTION (r);
          continue;
        }
      }

      // VALUES
      //
      {
        if (e.name () == "VALUES" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< VALUES::type > r (
            VALUES::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->VALUES ())
            continue;
          this->VALUES (r);
          continue;
        }
      }

      // LINK
      //
      {
        if (e.name () == "LINK" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< LINK::type > r (
            LINK::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->LINK ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "unit" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit::type > r (
          unit::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->unit (r);
        continue;
      }

      if (a.name () == "datatype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< datatype::type > r (
          datatype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->datatype (r);
        continue;
      }

      if (a.name () == "precision" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< precision::type > r (
          precision::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->precision (r);
        continue;
      }

      if (a.name () == "width" && a.namespace_ ().empty ())
      {
        this->width (
          width::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "ucd" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd::type > r (
          ucd::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ucd (r);
        continue;
      }

      if (a.name () == "utype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype::type > r (
          utype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->utype (r);
        continue;
      }

      if (a.name () == "arraysize" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< arraysize::type > r (
          arraysize::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->arraysize (r);
        continue;
      }

      if (a.name () == "type" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< type::type_ > r (
          type::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->type (r);
        continue;
      }
    }

    if (!_xsd_datatype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "datatype",
        "");
    }

    if (!_xsd_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  FIELD* FIELD::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new FIELD (*this, f, c);
  }

  // GROUP
  //

  GROUP::
  GROUP ()
  : ::xml_schema::type (),
  _xsd_DESCRIPTION_ (::xml_schema::flags (), this),
  _xsd_FIELDref_ (::xml_schema::flags (), this),
  _xsd_PARAMref_ (::xml_schema::flags (), this),
  _xsd_PARAM_ (::xml_schema::flags (), this),
  _xsd_GROUP1_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_name_ (::xml_schema::flags (), this),
  _xsd_ref_ (::xml_schema::flags (), this),
  _xsd_ucd_ (::xml_schema::flags (), this),
  _xsd_utype_ (::xml_schema::flags (), this)
  {
  }

  GROUP::
  GROUP (const GROUP& _xsd_GROUP,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_GROUP, f, c),
  _xsd_DESCRIPTION_ (_xsd_GROUP._xsd_DESCRIPTION_,
                     f | ::xml_schema::flags::not_root,
                     this),
  _xsd_FIELDref_ (_xsd_GROUP._xsd_FIELDref_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_PARAMref_ (_xsd_GROUP._xsd_PARAMref_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_PARAM_ (_xsd_GROUP._xsd_PARAM_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_GROUP1_ (_xsd_GROUP._xsd_GROUP1_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_ID_ (_xsd_GROUP._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_name_ (_xsd_GROUP._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ref_ (_xsd_GROUP._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_ucd_ (_xsd_GROUP._xsd_ucd_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_utype_ (_xsd_GROUP._xsd_utype_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  GROUP::
  GROUP (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_DESCRIPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_FIELDref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_PARAMref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_PARAM_ (f | ::xml_schema::flags::not_root, this),
  _xsd_GROUP1_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ucd_ (f | ::xml_schema::flags::not_root, this),
  _xsd_utype_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void GROUP::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // DESCRIPTION
      //
      {
        if (e.name () == "DESCRIPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< DESCRIPTION::type > r (
            DESCRIPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->DESCRIPTION ())
            continue;
          this->DESCRIPTION (r);
          continue;
        }
      }

      // FIELDref
      //
      {
        if (e.name () == "FIELDref" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< FIELDref::type > r (
            FIELDref::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->FIELDref ().push_back (r);
          continue;
        }
      }

      // PARAMref
      //
      {
        if (e.name () == "PARAMref" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< PARAMref::type > r (
            PARAMref::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->PARAMref ().push_back (r);
          continue;
        }
      }

      // PARAM
      //
      {
        if (e.name () == "PARAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< PARAM::type > r (
            PARAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->PARAM ().push_back (r);
          continue;
        }
      }

      // GROUP1
      //
      {
        if (e.name () == "GROUP" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< GROUP1::type > r (
            GROUP1::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->GROUP1 ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }

      if (a.name () == "ucd" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ucd::type > r (
          ucd::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ucd (r);
        continue;
      }

      if (a.name () == "utype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< utype::type > r (
          utype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->utype (r);
        continue;
      }
    }
  }

  GROUP* GROUP::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new GROUP (*this, f, c);
  }

  // FIELDref
  //

  FIELDref::
  FIELDref (const ref::type& _xsd_ref)
  : ::xml_schema::type (),
  _xsd_ref_ (_xsd_ref,
             ::xml_schema::flags (),
             this)
  {
  }

  FIELDref::
  FIELDref (const FIELDref& _xsd_FIELDref,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_FIELDref, f, c),
  _xsd_ref_ (_xsd_FIELDref._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this)
  {
  }

  FIELDref::
  FIELDref (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void FIELDref::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }
    }

    if (!_xsd_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  FIELDref* FIELDref::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new FIELDref (*this, f, c);
  }

  // PARAMref
  //

  PARAMref::
  PARAMref (const ref::type& _xsd_ref)
  : ::xml_schema::type (),
  _xsd_ref_ (_xsd_ref,
             ::xml_schema::flags (),
             this)
  {
  }

  PARAMref::
  PARAMref (const PARAMref& _xsd_PARAMref,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_PARAMref, f, c),
  _xsd_ref_ (_xsd_PARAMref._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this)
  {
  }

  PARAMref::
  PARAMref (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void PARAMref::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }
    }

    if (!_xsd_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ref",
        "");
    }
  }

  PARAMref* PARAMref::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new PARAMref (*this, f, c);
  }

  // VALUES
  //

  // VALUES::type
  // 

  const VALUES::type::type_ VALUES::type::default_value_ (
    ::std::basic_string< char > ("legal"), 0, 0, 0);

  VALUES::
  VALUES ()
  : ::xml_schema::type (),
  _xsd_MIN_ (::xml_schema::flags (), this),
  _xsd_MAX_ (::xml_schema::flags (), this),
  _xsd_OPTION_ (::xml_schema::flags (), this),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_type_ (type::default_value (),
              ::xml_schema::flags (),
              this),
  _xsd_null_ (::xml_schema::flags (), this),
  _xsd_ref_ (::xml_schema::flags (), this)
  {
  }

  VALUES::
  VALUES (const VALUES& _xsd_VALUES,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_VALUES, f, c),
  _xsd_MIN_ (_xsd_VALUES._xsd_MIN_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_MAX_ (_xsd_VALUES._xsd_MAX_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_OPTION_ (_xsd_VALUES._xsd_OPTION_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_ID_ (_xsd_VALUES._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_type_ (_xsd_VALUES._xsd_type_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_null_ (_xsd_VALUES._xsd_null_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_ref_ (_xsd_VALUES._xsd_ref_,
             f | ::xml_schema::flags::not_root,
             this)
  {
  }

  VALUES::
  VALUES (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_MIN_ (f | ::xml_schema::flags::not_root, this),
  _xsd_MAX_ (f | ::xml_schema::flags::not_root, this),
  _xsd_OPTION_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_type_ (f | ::xml_schema::flags::not_root, this),
  _xsd_null_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ref_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void VALUES::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // MIN
      //
      {
        if (e.name () == "MIN" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< MIN::type > r (
            MIN::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->MIN ())
            continue;
          this->MIN (r);
          continue;
        }
      }

      // MAX
      //
      {
        if (e.name () == "MAX" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< MAX::type > r (
            MAX::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->MAX ())
            continue;
          this->MAX (r);
          continue;
        }
      }

      // OPTION
      //
      {
        if (e.name () == "OPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< OPTION::type > r (
            OPTION::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->OPTION ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "type" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< type::type_ > r (
          type::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->type (r);
        continue;
      }

      if (a.name () == "null" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< null::type > r (
          null::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->null (r);
        continue;
      }

      if (a.name () == "ref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ref::type > r (
          ref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ref (r);
        continue;
      }
    }

    if (!_xsd_type_.present ())
    {
      this->type (
        type::traits::create (
          ::std::basic_string< char > ("legal"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }
  }

  VALUES* VALUES::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new VALUES (*this, f, c);
  }

  // MIN
  //

  // MIN::inclusive
  // 

  const MIN::inclusive::type MIN::inclusive::default_value_ (
    ::std::basic_string< char > ("yes"), 0, 0, 0);

  MIN::
  MIN (const value::type& _xsd_value)
  : ::xml_schema::type (),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this),
  _xsd_inclusive_ (inclusive::default_value (),
                   ::xml_schema::flags (),
                   this)
  {
  }

  MIN::
  MIN (const MIN& _xsd_MIN,
       ::xml_schema::flags f,
       ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_MIN, f, c),
  _xsd_value_ (_xsd_MIN._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_inclusive_ (_xsd_MIN._xsd_inclusive_,
                   f | ::xml_schema::flags::not_root,
                   this)
  {
  }

  MIN::
  MIN (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_inclusive_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void MIN::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "value" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< value::type > r (
          value::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->value (r);
        continue;
      }

      if (a.name () == "inclusive" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< inclusive::type > r (
          inclusive::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->inclusive (r);
        continue;
      }
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!_xsd_inclusive_.present ())
    {
      this->inclusive (
        inclusive::traits::create (
          ::std::basic_string< char > ("yes"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }
  }

  MIN* MIN::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new MIN (*this, f, c);
  }

  // MAX
  //

  // MAX::inclusive
  // 

  const MAX::inclusive::type MAX::inclusive::default_value_ (
    ::std::basic_string< char > ("yes"), 0, 0, 0);

  MAX::
  MAX (const value::type& _xsd_value)
  : ::xml_schema::type (),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this),
  _xsd_inclusive_ (inclusive::default_value (),
                   ::xml_schema::flags (),
                   this)
  {
  }

  MAX::
  MAX (const MAX& _xsd_MAX,
       ::xml_schema::flags f,
       ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_MAX, f, c),
  _xsd_value_ (_xsd_MAX._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_inclusive_ (_xsd_MAX._xsd_inclusive_,
                   f | ::xml_schema::flags::not_root,
                   this)
  {
  }

  MAX::
  MAX (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_inclusive_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void MAX::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "value" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< value::type > r (
          value::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->value (r);
        continue;
      }

      if (a.name () == "inclusive" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< inclusive::type > r (
          inclusive::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->inclusive (r);
        continue;
      }
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!_xsd_inclusive_.present ())
    {
      this->inclusive (
        inclusive::traits::create (
          ::std::basic_string< char > ("yes"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }
  }

  MAX* MAX::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new MAX (*this, f, c);
  }

  // OPTION
  //

  OPTION::
  OPTION (const value::type& _xsd_value)
  : ::xml_schema::type (),
  _xsd_OPTION1_ (::xml_schema::flags (), this),
  _xsd_name_ (::xml_schema::flags (), this),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this)
  {
  }

  OPTION::
  OPTION (const OPTION& _xsd_OPTION,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_OPTION, f, c),
  _xsd_OPTION1_ (_xsd_OPTION._xsd_OPTION1_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_name_ (_xsd_OPTION._xsd_name_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_value_ (_xsd_OPTION._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  OPTION::
  OPTION (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_OPTION1_ (f | ::xml_schema::flags::not_root, this),
  _xsd_name_ (f | ::xml_schema::flags::not_root, this),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void OPTION::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // OPTION1
      //
      {
        if (e.name () == "OPTION" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< OPTION1::type > r (
            OPTION1::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->OPTION1 ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "name" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< name::type > r (
          name::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->name (r);
        continue;
      }

      if (a.name () == "value" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< value::type > r (
          value::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->value (r);
        continue;
      }
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  OPTION* OPTION::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new OPTION (*this, f, c);
  }

  // LINK
  //

  LINK::
  LINK ()
  : ::xml_schema::type (),
  _xsd_ID_ (::xml_schema::flags (), this),
  _xsd_content_role_ (::xml_schema::flags (), this),
  _xsd_content_type_ (::xml_schema::flags (), this),
  _xsd_title_ (::xml_schema::flags (), this),
  _xsd_value_ (::xml_schema::flags (), this),
  _xsd_href_ (::xml_schema::flags (), this),
  _xsd_gref_ (::xml_schema::flags (), this),
  _xsd_action_ (::xml_schema::flags (), this)
  {
  }

  LINK::
  LINK (const LINK& _xsd_LINK,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_LINK, f, c),
  _xsd_ID_ (_xsd_LINK._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_content_role_ (_xsd_LINK._xsd_content_role_,
                      f | ::xml_schema::flags::not_root,
                      this),
  _xsd_content_type_ (_xsd_LINK._xsd_content_type_,
                      f | ::xml_schema::flags::not_root,
                      this),
  _xsd_title_ (_xsd_LINK._xsd_title_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_value_ (_xsd_LINK._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_href_ (_xsd_LINK._xsd_href_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_gref_ (_xsd_LINK._xsd_gref_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_action_ (_xsd_LINK._xsd_action_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  LINK::
  LINK (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_content_role_ (f | ::xml_schema::flags::not_root, this),
  _xsd_content_type_ (f | ::xml_schema::flags::not_root, this),
  _xsd_title_ (f | ::xml_schema::flags::not_root, this),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_href_ (f | ::xml_schema::flags::not_root, this),
  _xsd_gref_ (f | ::xml_schema::flags::not_root, this),
  _xsd_action_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void LINK::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "content-role" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< content_role::type > r (
          content_role::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->content_role (r);
        continue;
      }

      if (a.name () == "content-type" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< content_type::type > r (
          content_type::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->content_type (r);
        continue;
      }

      if (a.name () == "title" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< title::type > r (
          title::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->title (r);
        continue;
      }

      if (a.name () == "value" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< value::type > r (
          value::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->value (r);
        continue;
      }

      if (a.name () == "href" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< href::type > r (
          href::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->href (r);
        continue;
      }

      if (a.name () == "gref" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< gref::type > r (
          gref::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->gref (r);
        continue;
      }

      if (a.name () == "action" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< action::type > r (
          action::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->action (r);
        continue;
      }
    }
  }

  LINK* LINK::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new LINK (*this, f, c);
  }

  // DATA
  //

  DATA::
  DATA ()
  : ::xml_schema::type (),
  _xsd_TABLEDATA_ (::xml_schema::flags (), this),
  _xsd_BINARY_ (::xml_schema::flags (), this),
  _xsd_FITS_ (::xml_schema::flags (), this)
  {
  }

  DATA::
  DATA (const DATA& _xsd_DATA,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_DATA, f, c),
  _xsd_TABLEDATA_ (_xsd_DATA._xsd_TABLEDATA_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_BINARY_ (_xsd_DATA._xsd_BINARY_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_FITS_ (_xsd_DATA._xsd_FITS_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  DATA::
  DATA (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_TABLEDATA_ (f | ::xml_schema::flags::not_root, this),
  _xsd_BINARY_ (f | ::xml_schema::flags::not_root, this),
  _xsd_FITS_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void DATA::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // TABLEDATA
      //
      {
        if (e.name () == "TABLEDATA" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< TABLEDATA::type > r (
            TABLEDATA::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->TABLEDATA ())
            continue;
          this->TABLEDATA (r);
          continue;
        }
      }

      // BINARY
      //
      {
        if (e.name () == "BINARY" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< BINARY::type > r (
            BINARY::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->BINARY ())
            continue;
          this->BINARY (r);
          continue;
        }
      }

      // FITS
      //
      {
        if (e.name () == "FITS" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< FITS::type > r (
            FITS::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->FITS ())
            continue;
          this->FITS (r);
          continue;
        }
      }
    }
  }

  DATA* DATA::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new DATA (*this, f, c);
  }

  // TABLEDATA
  //

  TABLEDATA::
  TABLEDATA ()
  : ::xml_schema::type (),
  _xsd_TR_ (::xml_schema::flags (), this)
  {
  }

  TABLEDATA::
  TABLEDATA (const TABLEDATA& _xsd_TABLEDATA,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_TABLEDATA, f, c),
  _xsd_TR_ (_xsd_TABLEDATA._xsd_TR_,
            f | ::xml_schema::flags::not_root,
            this)
  {
  }

  TABLEDATA::
  TABLEDATA (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_TR_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void TABLEDATA::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // TR
      //
      {
        if (e.name () == "TR" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< TR::type > r (
            TR::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->TR ().push_back (r);
          continue;
        }
      }
    }
  }

  TABLEDATA* TABLEDATA::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new TABLEDATA (*this, f, c);
  }

  // TD
  //

  TD::
  TD (const _xsd_TD::base_& _xsd_TD)
  : ::xml_schema::string (_xsd_TD),
  _xsd_encoding_ (::xml_schema::flags (), this)
  {
  }

  TD::
  TD (const TD& _xsd_TD,
      ::xml_schema::flags f,
      ::xml_schema::type* c)
  : ::xml_schema::string (_xsd_TD, f, c),
  _xsd_encoding_ (_xsd_TD._xsd_encoding_,
                  f | ::xml_schema::flags::not_root,
                  this)
  {
  }

  TD::
  TD (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::type* c)
  : ::xml_schema::string (e, f, c),
  _xsd_encoding_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void TD::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "encoding" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< encoding::type > r (
          encoding::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->encoding (r);
        continue;
      }
    }
  }

  TD* TD::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new TD (*this, f, c);
  }

  // TR
  //

  TR::
  TR ()
  : ::xml_schema::type (),
  _xsd_TD_ (::xml_schema::flags (), this)
  {
  }

  TR::
  TR (const TR& _xsd_TR,
      ::xml_schema::flags f,
      ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_TR, f, c),
  _xsd_TD_ (_xsd_TR._xsd_TD_,
            f | ::xml_schema::flags::not_root,
            this)
  {
  }

  TR::
  TR (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_TD_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void TR::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // TD
      //
      {
        if (e.name () == "TD" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< TD::type > r (
            TD::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->TD ().push_back (r);
          continue;
        }
      }
    }
  }

  TR* TR::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new TR (*this, f, c);
  }

  // FITS
  //

  FITS::
  FITS (const STREAM::type& _xsd_STREAM)
  : ::xml_schema::type (),
  _xsd_STREAM_ (_xsd_STREAM,
                ::xml_schema::flags (),
                this),
  _xsd_extnum_ (::xml_schema::flags (), this)
  {
  }

  FITS::
  FITS (const FITS& _xsd_FITS,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_FITS, f, c),
  _xsd_STREAM_ (_xsd_FITS._xsd_STREAM_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_extnum_ (_xsd_FITS._xsd_extnum_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  FITS::
  FITS (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_STREAM_ (f | ::xml_schema::flags::not_root, this),
  _xsd_extnum_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void FITS::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // STREAM
      //
      {
        if (e.name () == "STREAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< STREAM::type > r (
            STREAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_STREAM_.present ())
            continue;
          this->STREAM (r);
          continue;
        }
      }
    }

    if (!_xsd_STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.1");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "extnum" && a.namespace_ ().empty ())
      {
        this->extnum (
          extnum::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }
  }

  FITS* FITS::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new FITS (*this, f, c);
  }

  // BINARY
  //

  BINARY::
  BINARY (const STREAM::type& _xsd_STREAM)
  : ::xml_schema::type (),
  _xsd_STREAM_ (_xsd_STREAM,
                ::xml_schema::flags (),
                this)
  {
  }

  BINARY::
  BINARY (const BINARY& _xsd_BINARY,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_BINARY, f, c),
  _xsd_STREAM_ (_xsd_BINARY._xsd_STREAM_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  BINARY::
  BINARY (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_STREAM_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void BINARY::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // STREAM
      //
      {
        if (e.name () == "STREAM" && e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
        {
          ::std::auto_ptr< STREAM::type > r (
            STREAM::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_STREAM_.present ())
            continue;
          this->STREAM (r);
          continue;
        }
      }
    }

    if (!_xsd_STREAM_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.1");
    }
  }

  BINARY* BINARY::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new BINARY (*this, f, c);
  }

  // STREAM
  //

  // STREAM::type
  // 

  const STREAM::type::type_ STREAM::type::default_value_ (
    ::std::basic_string< char > ("locator"), 0, 0, 0);

  // STREAM::actuate
  // 

  const STREAM::actuate::type STREAM::actuate::default_value_ (
    ::std::basic_string< char > ("onRequest"), 0, 0, 0);

  // STREAM::encoding
  // 

  const STREAM::encoding::type STREAM::encoding::default_value_ (
    ::std::basic_string< char > ("none"), 0, 0, 0);

  STREAM::
  STREAM (const _xsd_STREAM::base_& _xsd_STREAM)
  : ::xml_schema::string (_xsd_STREAM),
  _xsd_type_ (type::default_value (),
              ::xml_schema::flags (),
              this),
  _xsd_href_ (::xml_schema::flags (), this),
  _xsd_actuate_ (actuate::default_value (),
                 ::xml_schema::flags (),
                 this),
  _xsd_encoding_ (encoding::default_value (),
                  ::xml_schema::flags (),
                  this),
  _xsd_expires_ (::xml_schema::flags (), this),
  _xsd_rights_ (::xml_schema::flags (), this)
  {
  }

  STREAM::
  STREAM (const STREAM& _xsd_STREAM,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::string (_xsd_STREAM, f, c),
  _xsd_type_ (_xsd_STREAM._xsd_type_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_href_ (_xsd_STREAM._xsd_href_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_actuate_ (_xsd_STREAM._xsd_actuate_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_encoding_ (_xsd_STREAM._xsd_encoding_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_expires_ (_xsd_STREAM._xsd_expires_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_rights_ (_xsd_STREAM._xsd_rights_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  STREAM::
  STREAM (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::string (e, f, c),
  _xsd_type_ (f | ::xml_schema::flags::not_root, this),
  _xsd_href_ (f | ::xml_schema::flags::not_root, this),
  _xsd_actuate_ (f | ::xml_schema::flags::not_root, this),
  _xsd_encoding_ (f | ::xml_schema::flags::not_root, this),
  _xsd_expires_ (f | ::xml_schema::flags::not_root, this),
  _xsd_rights_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void STREAM::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "type" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< type::type_ > r (
          type::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->type (r);
        continue;
      }

      if (a.name () == "href" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< href::type > r (
          href::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->href (r);
        continue;
      }

      if (a.name () == "actuate" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< actuate::type > r (
          actuate::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->actuate (r);
        continue;
      }

      if (a.name () == "encoding" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< encoding::type > r (
          encoding::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->encoding (r);
        continue;
      }

      if (a.name () == "expires" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< expires::type > r (
          expires::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->expires (r);
        continue;
      }

      if (a.name () == "rights" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< rights::type > r (
          rights::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->rights (r);
        continue;
      }
    }

    if (!_xsd_type_.present ())
    {
      this->type (
        type::traits::create (
          ::std::basic_string< char > ("locator"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }

    if (!_xsd_actuate_.present ())
    {
      this->actuate (
        actuate::traits::create (
          ::std::basic_string< char > ("onRequest"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }

    if (!_xsd_encoding_.present ())
    {
      this->encoding (
        encoding::traits::create (
          ::std::basic_string< char > ("none"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }
  }

  STREAM* STREAM::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new STREAM (*this, f, c);
  }

  // COOSYS
  //

  // COOSYS::system
  // 

  const COOSYS::system::type COOSYS::system::default_value_ (
    ::std::basic_string< char > ("eq_FK5"), 0, 0, 0);

  COOSYS::
  COOSYS (const _xsd_COOSYS::base_& _xsd_COOSYS,
          const ID::type& _xsd_ID)
  : ::xml_schema::string (_xsd_COOSYS),
  _xsd_ID_ (_xsd_ID,
            ::xml_schema::flags (),
            this),
  _xsd_equinox_ (::xml_schema::flags (), this),
  _xsd_epoch_ (::xml_schema::flags (), this),
  _xsd_system_ (system::default_value (),
                ::xml_schema::flags (),
                this)
  {
  }

  COOSYS::
  COOSYS (const COOSYS& _xsd_COOSYS,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::string (_xsd_COOSYS, f, c),
  _xsd_ID_ (_xsd_COOSYS._xsd_ID_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_equinox_ (_xsd_COOSYS._xsd_equinox_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_epoch_ (_xsd_COOSYS._xsd_epoch_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_system_ (_xsd_COOSYS._xsd_system_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  COOSYS::
  COOSYS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::string (e, f, c),
  _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
  _xsd_equinox_ (f | ::xml_schema::flags::not_root, this),
  _xsd_epoch_ (f | ::xml_schema::flags::not_root, this),
  _xsd_system_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void COOSYS::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ID" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ID::type > r (
          ID::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ID (r);
        continue;
      }

      if (a.name () == "equinox" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< equinox::type > r (
          equinox::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->equinox (r);
        continue;
      }

      if (a.name () == "epoch" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< epoch::type > r (
          epoch::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->epoch (r);
        continue;
      }

      if (a.name () == "system" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< system::type > r (
          system::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->system (r);
        continue;
      }
    }

    if (!_xsd_ID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ID",
        "");
    }

    if (!_xsd_system_.present ())
    {
      this->system (
        system::traits::create (
          ::std::basic_string< char > ("eq_FK5"),
          &e,
          f | ::xml_schema::flags::not_root,
          this));
    }
  }

  COOSYS* COOSYS::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new COOSYS (*this, f, c);
  }

  // version
  //

  version::
  version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_version_convert ();
  }

  version::
  version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_version_convert ();
  }

  version::
  version (const ::std::basic_string< char >& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_version_convert ();
  }

  version* version::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new version (*this, f, c);
  }

  version::_xsd_version version::
  _xsd_version_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_version_literals_);
    const _xsd_version* i (::std::lower_bound (
                             _xsd_version_indexes_,
                             _xsd_version_indexes_ + 1,
                             *this,
                             c));

    if (i == _xsd_version_indexes_ + 1 || _xsd_version_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const version::
  _xsd_version_literals_[1] =
  {
    "1.1"
  };

  const version::_xsd_version version::
  _xsd_version_indexes_[1] =
  {
    ::votable::version::cxx_1_1
  };

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::basic_string< char >& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new type (*this, f, c);
  }

  type::_xsd_type type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const _xsd_type* i (::std::lower_bound (
                          _xsd_type_indexes_,
                          _xsd_type_indexes_ + 2,
                          *this,
                          c));

    if (i == _xsd_type_indexes_ + 2 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[2] =
  {
    "results",
    "meta"
  };

  const type::_xsd_type type::
  _xsd_type_indexes_[2] =
  {
    ::votable::type::meta,
    ::votable::type::results
  };

  // type1
  //

  type1::
  type1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type1_convert ();
  }

  type1::
  type1 (const ::std::basic_string< char >& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type1_convert ();
  }

  type1* type1::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new type1 (*this, f, c);
  }

  type1::_xsd_type1 type1::
  _xsd_type1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type1_literals_);
    const _xsd_type1* i (::std::lower_bound (
                           _xsd_type1_indexes_,
                           _xsd_type1_indexes_ + 4,
                           *this,
                           c));

    if (i == _xsd_type1_indexes_ + 4 || _xsd_type1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type1::
  _xsd_type1_literals_[4] =
  {
    "hidden",
    "no_query",
    "trigger",
    "location"
  };

  const type1::_xsd_type1 type1::
  _xsd_type1_indexes_[4] =
  {
    ::votable::type1::hidden,
    ::votable::type1::location,
    ::votable::type1::no_query,
    ::votable::type1::trigger
  };

  // type2
  //

  type2::
  type2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type2_convert ();
  }

  type2::
  type2 (const ::std::basic_string< char >& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type2_convert ();
  }

  type2* type2::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new type2 (*this, f, c);
  }

  type2::_xsd_type2 type2::
  _xsd_type2_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type2_literals_);
    const _xsd_type2* i (::std::lower_bound (
                           _xsd_type2_indexes_,
                           _xsd_type2_indexes_ + 2,
                           *this,
                           c));

    if (i == _xsd_type2_indexes_ + 2 || _xsd_type2_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type2::
  _xsd_type2_literals_[2] =
  {
    "legal",
    "actual"
  };

  const type2::_xsd_type2 type2::
  _xsd_type2_indexes_[2] =
  {
    ::votable::type2::actual,
    ::votable::type2::legal
  };

  // content_role
  //

  content_role::
  content_role (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_content_role_convert ();
  }

  content_role::
  content_role (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_content_role_convert ();
  }

  content_role::
  content_role (const ::std::basic_string< char >& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_content_role_convert ();
  }

  content_role* content_role::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new content_role (*this, f, c);
  }

  content_role::_xsd_content_role content_role::
  _xsd_content_role_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_content_role_literals_);
    const _xsd_content_role* i (::std::lower_bound (
                                  _xsd_content_role_indexes_,
                                  _xsd_content_role_indexes_ + 4,
                                  *this,
                                  c));

    if (i == _xsd_content_role_indexes_ + 4 || _xsd_content_role_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const content_role::
  _xsd_content_role_literals_[4] =
  {
    "query",
    "hints",
    "doc",
    "location"
  };

  const content_role::_xsd_content_role content_role::
  _xsd_content_role_indexes_[4] =
  {
    ::votable::content_role::doc,
    ::votable::content_role::hints,
    ::votable::content_role::location,
    ::votable::content_role::query
  };

  // type3
  //

  type3::
  type3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_type3_convert ();
  }

  type3::
  type3 (const ::std::basic_string< char >& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_type3_convert ();
  }

  type3* type3::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new type3 (*this, f, c);
  }

  type3::_xsd_type3 type3::
  _xsd_type3_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type3_literals_);
    const _xsd_type3* i (::std::lower_bound (
                           _xsd_type3_indexes_,
                           _xsd_type3_indexes_ + 2,
                           *this,
                           c));

    if (i == _xsd_type3_indexes_ + 2 || _xsd_type3_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type3::
  _xsd_type3_literals_[2] =
  {
    "locator",
    "other"
  };

  const type3::_xsd_type3 type3::
  _xsd_type3_indexes_[2] =
  {
    ::votable::type3::locator,
    ::votable::type3::other
  };

  // actuate
  //

  actuate::
  actuate (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate::
  actuate (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate::
  actuate (const ::std::basic_string< char >& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_actuate_convert ();
  }

  actuate* actuate::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new actuate (*this, f, c);
  }

  actuate::_xsd_actuate actuate::
  _xsd_actuate_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_actuate_literals_);
    const _xsd_actuate* i (::std::lower_bound (
                             _xsd_actuate_indexes_,
                             _xsd_actuate_indexes_ + 4,
                             *this,
                             c));

    if (i == _xsd_actuate_indexes_ + 4 || _xsd_actuate_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const actuate::
  _xsd_actuate_literals_[4] =
  {
    "onLoad",
    "onRequest",
    "other",
    "none"
  };

  const actuate::_xsd_actuate actuate::
  _xsd_actuate_indexes_[4] =
  {
    ::votable::actuate::none,
    ::votable::actuate::onLoad,
    ::votable::actuate::onRequest,
    ::votable::actuate::other
  };

  // system
  //

  system::
  system (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
    _xsd_system_convert ();
  }

  system::
  system (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
    _xsd_system_convert ();
  }

  system::
  system (const ::std::basic_string< char >& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
    _xsd_system_convert ();
  }

  system* system::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new system (*this, f, c);
  }

  system::_xsd_system system::
  _xsd_system_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_literals_);
    const _xsd_system* i (::std::lower_bound (
                            _xsd_system_indexes_,
                            _xsd_system_indexes_ + 10,
                            *this,
                            c));

    if (i == _xsd_system_indexes_ + 10 || _xsd_system_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const system::
  _xsd_system_literals_[10] =
  {
    "eq_FK4",
    "eq_FK5",
    "ICRS",
    "ecl_FK4",
    "ecl_FK5",
    "galactic",
    "supergalactic",
    "xy",
    "barycentric",
    "geo_app"
  };

  const system::_xsd_system system::
  _xsd_system_indexes_[10] =
  {
    ::votable::system::ICRS,
    ::votable::system::barycentric,
    ::votable::system::ecl_FK4,
    ::votable::system::ecl_FK5,
    ::votable::system::eq_FK4,
    ::votable::system::eq_FK5,
    ::votable::system::galactic,
    ::votable::system::geo_app,
    ::votable::system::supergalactic,
    ::votable::system::xy
  };
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace votable
{
  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::std::basic_string< char >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::votable::VOTABLE_ (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::std::basic_string< char >& u,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::votable::VOTABLE_ (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::std::basic_string< char >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::votable::VOTABLE_ (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::votable::VOTABLE_ (wrap, f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream& is,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::votable::VOTABLE_ (wrap, h, f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::votable::VOTABLE_ (wrap, h, f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::votable::VOTABLE_ (wrap, f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::votable::VOTABLE_ (wrap, h, f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::votable::VOTABLE_ (wrap, h, f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::votable::VOTABLE_ (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::votable::VOTABLE_ (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::votable::VOTABLE_ (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::votable::VOTABLE >
  VOTABLE_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >&)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
      (f & ::xml_schema::flags::keep_dom) 
      ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
      : 0);

    const ::xsd::cxx::xml::dom::element< char > e (
      c.get ()
      ? *c->getDocumentElement ()
      : *d.getDocumentElement ());

   if (e.name () == "VOTABLE" &&
        e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
    {
      ::std::auto_ptr< ::votable::VOTABLE > r (
        ::xsd::cxx::tree::traits< ::votable::VOTABLE, char >::create (
          e.dom_element (), f, 0));
      if (f & ::xml_schema::flags::keep_dom) c.release ();
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      e.name (),
      e.namespace_ (),
      "VOTABLE",
      "http://www.ivoa.net/xml/VOTable/v1.1");
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace votable
{
  void
  operator<< (::xercesc::DOMElement& e,
              const anyTEXT&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const anyTEXT&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const anyTEXT&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const astroYear& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              const astroYear& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              const astroYear& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ucdType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              const ucdType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              const ucdType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const arrayDEF& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              const arrayDEF& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              const arrayDEF& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              encodingType i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              encodingType i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              encodingType i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              dataType i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              dataType i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              dataType i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const precType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              const precType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              const precType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              yesno i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              yesno i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              yesno i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  VOTABLE_ (::xercesc::DOMDocument& d,
            const ::votable::VOTABLE& s,
            ::xml_schema::flags)
  {
    ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

    if (e.name () == "VOTABLE" &&
        e.namespace_ () == "http://www.ivoa.net/xml/VOTable/v1.1")
    {
      e.dom_element () << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        e.name (),
        e.namespace_ (),
        "VOTABLE",
        "http://www.ivoa.net/xml/VOTable/v1.1");
    }
  }

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
  VOTABLE_ (const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xml_schema::flags f)
  {
    try
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "VOTABLE",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          m,
          f));
      ::votable::VOTABLE_ (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  VOTABLE_ (::xercesc::XMLFormatTarget& t,
            const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable::VOTABLE_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  VOTABLE_ (::xercesc::XMLFormatTarget& t,
            const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable::VOTABLE_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_ (::xercesc::XMLFormatTarget& t,
            const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable::VOTABLE_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_ (::std::ostream& o,
            const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable::VOTABLE_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  VOTABLE_ (::std::ostream& o,
            const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable::VOTABLE_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VOTABLE_ (::std::ostream& o,
            const ::votable::VOTABLE& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::votable::VOTABLE_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const VOTABLE& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.DESCRIPTION ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DESCRIPTION ();
      }
    }

    {
      if (i.DEFINITIONS ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DEFINITIONS",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DEFINITIONS ();
      }
    }

    {
      for (VOTABLE::COOSYS::const_iterator
           b (i.COOSYS ().begin ()), n (i.COOSYS ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "COOSYS",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (VOTABLE::PARAM::const_iterator
           b (i.PARAM ().begin ()), n (i.PARAM ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (VOTABLE::INFO::const_iterator
           b (i.INFO ().begin ()), n (i.INFO ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "INFO",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (VOTABLE::RESOURCE::const_iterator
           b (i.RESOURCE ().begin ()), n (i.RESOURCE ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "RESOURCE",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.version ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "version",
        e);

      a.dom_attribute () << *i.version ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const RESOURCE& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.DESCRIPTION ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DESCRIPTION ();
      }
    }

    {
      for (RESOURCE::INFO::const_iterator
           b (i.INFO ().begin ()), n (i.INFO ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "INFO",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (RESOURCE::COOSYS::const_iterator
           b (i.COOSYS ().begin ()), n (i.COOSYS ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "COOSYS",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (RESOURCE::PARAM::const_iterator
           b (i.PARAM ().begin ()), n (i.PARAM ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (RESOURCE::LINK::const_iterator
           b (i.LINK ().begin ()), n (i.LINK ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (RESOURCE::TABLE::const_iterator
           b (i.TABLE ().begin ()), n (i.TABLE ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "TABLE",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (RESOURCE::RESOURCE1::const_iterator
           b (i.RESOURCE1 ().begin ()), n (i.RESOURCE1 ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "RESOURCE",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.name ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << *i.name ();
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.utype ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "utype",
        e);

      a.dom_attribute () << *i.utype ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "type",
        e);

      a.dom_attribute () << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const DEFINITIONS& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (DEFINITIONS::COOSYS::const_iterator
           b (i.COOSYS ().begin ()), n (i.COOSYS ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "COOSYS",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (DEFINITIONS::PARAM::const_iterator
           b (i.PARAM ().begin ()), n (i.PARAM ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const INFO& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << i.name ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "value",
        e);

      a.dom_attribute () << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const PARAM& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.DESCRIPTION ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DESCRIPTION ();
      }
    }

    {
      if (i.VALUES ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "VALUES",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.VALUES ();
      }
    }

    {
      for (PARAM::LINK::const_iterator
           b (i.LINK ().begin ()), n (i.LINK ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.unit ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "unit",
        e);

      a.dom_attribute () << *i.unit ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "datatype",
        e);

      a.dom_attribute () << i.datatype ();
    }

    if (i.precision ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "precision",
        e);

      a.dom_attribute () << *i.precision ();
    }

    if (i.width ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "width",
        e);

      a.dom_attribute () << *i.width ();
    }

    if (i.ref ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << *i.ref ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << i.name ();
    }

    if (i.ucd ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ucd",
        e);

      a.dom_attribute () << *i.ucd ();
    }

    if (i.utype ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "utype",
        e);

      a.dom_attribute () << *i.utype ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "value",
        e);

      a.dom_attribute () << i.value ();
    }

    if (i.arraysize ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "arraysize",
        e);

      a.dom_attribute () << *i.arraysize ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const TABLE& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.DESCRIPTION ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DESCRIPTION ();
      }
    }

    {
      for (TABLE::FIELD::const_iterator
           b (i.FIELD ().begin ()), n (i.FIELD ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "FIELD",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (TABLE::PARAM::const_iterator
           b (i.PARAM ().begin ()), n (i.PARAM ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (TABLE::GROUP::const_iterator
           b (i.GROUP ().begin ()), n (i.GROUP ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "GROUP",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (TABLE::LINK::const_iterator
           b (i.LINK ().begin ()), n (i.LINK ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      if (i.DATA ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DATA",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DATA ();
      }
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.name ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << *i.name ();
    }

    if (i.ref ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << *i.ref ();
    }

    if (i.ucd ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ucd",
        e);

      a.dom_attribute () << *i.ucd ();
    }

    if (i.utype ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "utype",
        e);

      a.dom_attribute () << *i.utype ();
    }

    if (i.nrows ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "nrows",
        e);

      a.dom_attribute () << *i.nrows ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const FIELD& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.DESCRIPTION ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DESCRIPTION ();
      }
    }

    {
      if (i.VALUES ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "VALUES",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.VALUES ();
      }
    }

    {
      for (FIELD::LINK::const_iterator
           b (i.LINK ().begin ()), n (i.LINK ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "LINK",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.unit ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "unit",
        e);

      a.dom_attribute () << *i.unit ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "datatype",
        e);

      a.dom_attribute () << i.datatype ();
    }

    if (i.precision ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "precision",
        e);

      a.dom_attribute () << *i.precision ();
    }

    if (i.width ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "width",
        e);

      a.dom_attribute () << *i.width ();
    }

    if (i.ref ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << *i.ref ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << i.name ();
    }

    if (i.ucd ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ucd",
        e);

      a.dom_attribute () << *i.ucd ();
    }

    if (i.utype ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "utype",
        e);

      a.dom_attribute () << *i.utype ();
    }

    if (i.arraysize ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "arraysize",
        e);

      a.dom_attribute () << *i.arraysize ();
    }

    if (i.type ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "type",
        e);

      a.dom_attribute () << *i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const GROUP& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.DESCRIPTION ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "DESCRIPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.DESCRIPTION ();
      }
    }

    {
      for (GROUP::FIELDref::const_iterator
           b (i.FIELDref ().begin ()), n (i.FIELDref ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "FIELDref",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (GROUP::PARAMref::const_iterator
           b (i.PARAMref ().begin ()), n (i.PARAMref ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "PARAMref",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (GROUP::PARAM::const_iterator
           b (i.PARAM ().begin ()), n (i.PARAM ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "PARAM",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (GROUP::GROUP1::const_iterator
           b (i.GROUP1 ().begin ()), n (i.GROUP1 ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "GROUP",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.name ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << *i.name ();
    }

    if (i.ref ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << *i.ref ();
    }

    if (i.ucd ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ucd",
        e);

      a.dom_attribute () << *i.ucd ();
    }

    if (i.utype ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "utype",
        e);

      a.dom_attribute () << *i.utype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const FIELDref& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << i.ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const PARAMref& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << i.ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const VALUES& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.MIN ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "MIN",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.MIN ();
      }
    }

    {
      if (i.MAX ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "MAX",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.MAX ();
      }
    }

    {
      for (VALUES::OPTION::const_iterator
           b (i.OPTION ().begin ()), n (i.OPTION ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "OPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "type",
        e);

      a.dom_attribute () << i.type ();
    }

    if (i.null ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "null",
        e);

      a.dom_attribute () << *i.null ();
    }

    if (i.ref ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ref",
        e);

      a.dom_attribute () << *i.ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const MIN& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "value",
        e);

      a.dom_attribute () << i.value ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "inclusive",
        e);

      a.dom_attribute () << i.inclusive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const MAX& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "value",
        e);

      a.dom_attribute () << i.value ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "inclusive",
        e);

      a.dom_attribute () << i.inclusive ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const OPTION& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (OPTION::OPTION1::const_iterator
           b (i.OPTION1 ().begin ()), n (i.OPTION1 ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "OPTION",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }

    if (i.name ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "name",
        e);

      a.dom_attribute () << *i.name ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "value",
        e);

      a.dom_attribute () << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const LINK& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    if (i.ID ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << *i.ID ();
    }

    if (i.content_role ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "content-role",
        e);

      a.dom_attribute () << *i.content_role ();
    }

    if (i.content_type ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "content-type",
        e);

      a.dom_attribute () << *i.content_type ();
    }

    if (i.title ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "title",
        e);

      a.dom_attribute () << *i.title ();
    }

    if (i.value ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "value",
        e);

      a.dom_attribute () << *i.value ();
    }

    if (i.href ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "href",
        e);

      a.dom_attribute () << *i.href ();
    }

    if (i.gref ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "gref",
        e);

      a.dom_attribute () << *i.gref ();
    }

    if (i.action ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "action",
        e);

      a.dom_attribute () << *i.action ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const DATA& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.TABLEDATA ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "TABLEDATA",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.TABLEDATA ();
      }
    }

    {
      if (i.BINARY ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "BINARY",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.BINARY ();
      }
    }

    {
      if (i.FITS ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "FITS",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *i.FITS ();
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const TABLEDATA& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (TABLEDATA::TR::const_iterator
           b (i.TR ().begin ()), n (i.TR ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "TR",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const TD& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    if (i.encoding ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "encoding",
        e);

      a.dom_attribute () << *i.encoding ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const TR& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (TR::TD::const_iterator
           b (i.TD ().begin ()), n (i.TD ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "TD",
          "http://www.ivoa.net/xml/VOTable/v1.1",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const FITS& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.1",
        e);
      s.dom_element () << i.STREAM ();
    }

    if (i.extnum ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "extnum",
        e);

      a.dom_attribute () << *i.extnum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const BINARY& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "STREAM",
        "http://www.ivoa.net/xml/VOTable/v1.1",
        e);
      s.dom_element () << i.STREAM ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const STREAM& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "type",
        e);

      a.dom_attribute () << i.type ();
    }

    if (i.href ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "href",
        e);

      a.dom_attribute () << *i.href ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "actuate",
        e);

      a.dom_attribute () << i.actuate ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "encoding",
        e);

      a.dom_attribute () << i.encoding ();
    }

    if (i.expires ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "expires",
        e);

      a.dom_attribute () << *i.expires ();
    }

    if (i.rights ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "rights",
        e);

      a.dom_attribute () << *i.rights ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const COOSYS& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ID",
        e);

      a.dom_attribute () << i.ID ();
    }

    if (i.equinox ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "equinox",
        e);

      a.dom_attribute () << *i.equinox ();
    }

    if (i.epoch ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "epoch",
        e);

      a.dom_attribute () << *i.epoch ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "system",
        e);

      a.dom_attribute () << i.system ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              version i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              version i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              version i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              type i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              type i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              type i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              type1 i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              type1 i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              type1 i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              type2 i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              type2 i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              type2 i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              content_role i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              content_role i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              content_role i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              type3 i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              type3 i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              type3 i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              actuate i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              actuate i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              actuate i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              system i)
  {
    e << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              system i)
  {
    a << static_cast< const ::xml_schema::nmtoken& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              system i)
  {
    l << static_cast< const ::xml_schema::nmtoken& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

